package main

import (
	"bytes"
	"fmt"
	"go/token"
	"os"
	"sort"

	"golang.org/x/exp/ebnf"
	"modernc.org/mathutil"
)

func generate(dst, src string) error {
	g, err := newGen(dst, src)
	if err != nil {
		return err
	}

	return g.gen()
}

type gen struct {
	b   bytes.Buffer
	dst string
	peg *grammar

	nextID int
}

func newGen(dst, src string) (*gen, error) {
	peg, err := loadPEG(src)
	if err != nil {
		return nil, err
	}

	return &gen{dst: dst, peg: peg}, nil
}

func (g *gen) w(format string, args ...interface{}) { fmt.Fprintf(&g.b, format, args...) }

func (g *gen) id() (r int) { r = g.nextID; g.nextID++; return r }

func (g *gen) tok(s string) token.Token {
	if r, ok := toks[s]; ok {
		return r
	}

	panic(todo("%q", s))
}

func (g *gen) gen() (err error) {
	defer func() {
		if e := recover(); e != nil {
			if err == nil {
				err = fmt.Errorf("%v", e)
			}
		}
		if err != nil {
			return
		}

		err = os.WriteFile(g.dst, g.b.Bytes(), 0660)
	}()

	// From https://golang.org/s/generatedcode (golang/go#13560 (comment));
	//
	// Generated files are marked by a line of text that matches the regular expression, in Go syntax:
	//
	//     ^// Code generated .* DO NOT EDIT\.$
	//

	g.w("// Code generated by '$ go test -gen -run TestGen' DO NOT EDIT.")
	g.w("\n\npackage main")
	var a []string
	for v := range g.peg.g {
		a = append(a, v)
	}
	sort.Strings(a)
	for _, nm := range a {
		g.nextID = 0
		p := g.peg.g[nm]
		if !token.IsExported(nm) {
			continue
		}

		g.w("\n\n// %sNode represents", nm)
		g.w("\n//\n//\t%s = %s .", nm, ebnfString(p.Expr))
		g.w("\ntype %sNode = struct{ noder }", nm)
		g.w("\n\nfunc (p *parser) %s() *%sNode {", unexport(nm), nm)
		if p.Expr == nil {
			g.w("\nreturn &%sNode{}", nm)
			g.w("\n}")
			continue
		}

		id := g.id()
		g.w("\nix := p.ix")
		g.expression(p.Expr, fmt.Sprintf("\ngoto _%d", id), false)
		g.w("\nreturn &%sNode{}", nm)
		g.w("\ngoto _%d", id)
		g.w("\n_%d:", id)
		g.w("\np.back(ix)")
		g.w("\nreturn nil")
		g.w("\n}")
	}
	return nil
}

func (g *gen) elsePart(out string) {
	if out != "" {
		g.w(" else {")
		g.w("%s", out)
		g.w("\n}")
	}
}

func (g *gen) defaultPart(out string) {
	if out != "" {
		g.w("\n;default:%s", out)
	}
}

func (g *gen) expression(e ebnf.Expression, out string, braced bool) {
	switch x := e.(type) {
	case ebnf.Alternative:
		g.alt(x, out)
	case *ebnf.Group:
		g.w("\n// %T: %s", x, ebnfString(x))
		c := g.peg.exprClosure(x.Body)
		g.w("\nswitch p.c().tok {")
		g.w("\ncase %v:", c.caseStr())
		g.expression(x.Body, out, false)
		if !c.hasEpsilon() {
			g.defaultPart(out)
		}
		g.w("\n}")
	case *ebnf.Name:
		nm := x.String
		if token.IsExported(nm) {
			p := g.peg.g[nm]
			c := g.peg.productClosures[p]
			switch p := g.peg.g[nm]; {
			case p.Expr == nil:
				g.w("\nif p.%s() == nil {", unexport(nm))
				g.w("%s", out)
				g.w("\n}")
			default:
				g.w("\nswitch p.c().tok {")
				g.w("\ncase %v:", c.caseStr())
				g.w("\nif p.%s() == nil {", unexport(nm))
				g.w("%s", out)
				g.w("\n}")
				if !c.hasEpsilon() {
					g.defaultPart(out)
				}
				g.w("\n}")
			}
			break
		}

		g.w("\nif p.c().tok == %s {", tokSource(g.tok(x.String)))
		g.w("\np.ix++")
		g.w("\np.budget--")
		g.w("\n}")
		g.elsePart(out)
	case *ebnf.Option:
		c := g.peg.exprClosure(x.Body)
		g.w("\n// %T: %s", x, ebnfString(x))
		g.w("\nswitch p.c().tok {")
		g.w("\ncase %v:", c.caseStr())
		ok := g.id()
		g.expression(x.Body, fmt.Sprintf("\ngoto _%d", ok), false)
		g.w("\n}")
		g.w("\n_%d:", ok)
	case *ebnf.Repetition:
		//TODO? specialize for single item .Body
		c := g.peg.exprClosure(x.Body)
		id := g.id()
		g.w("\n_%d:", id)
		ok := g.id()
		g.w("\n// %T: %s", x, ebnfString(x))
		g.w("\nswitch p.c().tok {")
		g.w("\ncase %v:", c.caseStr())
		g.expression(x.Body, fmt.Sprintf("\ngoto _%d", ok), true)
		g.w("\ngoto _%d", id)
		g.w("\n}")
		g.w("\n_%d:", ok)
	case ebnf.Sequence:
		g.w("\n// %T: %s", x, ebnfString(x))
		switch {
		case braced:
			g.w("\nix := p.ix")
			for _, v := range x {
				g.expression(v, fmt.Sprintf("\np.back(ix);%s", out), false)
			}
		default:
			g.w("\n{")
			g.w("\nix := p.ix")
			for _, v := range x {
				g.expression(v, fmt.Sprintf("\np.back(ix);%s", out), false)
			}
			g.w("\n}")
		}
	case *ebnf.Token:
		g.w("\nif p.c().tok == %s {", tokSource(g.tok(x.String)))
		g.w("\np.ix++")
		g.w("\np.budget--")
		g.w("\n}")
		g.elsePart(out)
	default:
		g.w("\n//TODO %T: '%s'", x, ebnfString(e))
		g.w("%s", out)
	}
}

func (g *gen) alt(x ebnf.Alternative, out string) {
	var cs []closure
	m := map[token.Token][]int{}
	for i, v := range x {
		c := g.peg.exprClosure(v).clone()
		cs = append(cs, c)
		for k := range c {
			m[k] = append(m[k], i)
		}
	}
	var mX []token.Token
	for k := range m {
		mX = append(mX, k)
	}
	sort.Slice(mX, func(i, j int) bool { return mX[i] < mX[j] })
	disjoint := map[string]closure{}
	for _, t := range mX {
		is := m[t]
		if len(is) == 0 {
			continue
		}

		k := fmt.Sprint(is)
		k = k[1 : len(k)-1]
		c := disjoint[k]
		c.add(t)
		disjoint[k] = c
	}
	var disjointX []string
	for k := range disjoint {
		disjointX = append(disjointX, k)
	}
	sort.Slice(disjointX, func(i, j int) bool {
		a := ints(disjointX[i])
		b := ints(disjointX[j])
		for k := range a[:mathutil.Min(len(a), len(b))] {
			if a[k] < b[k] {
				return true
			}

			if a[k] > b[k] {
				return false
			}
		}
		return len(a) < len(b)
	})
	// for _, v := range disjointX {
	// 	g.w("\n// case %v: %v", disjoint[v].caseStr(), v)
	// }
	g.w("\n// %T: %s", x, ebnfString(x))
	g.w("\nswitch p.c().tok {")
	needDefault := true
	for _, k := range disjointX {
		c := disjoint[k]
		if c.hasEpsilon() {
			needDefault = false
		}
		var xs []ebnf.Expression
		for _, v := range ints(k) {
			xs = append(xs, x[v])
		}
		switch {
		case len(c) == 1 && c.hasEpsilon():
			g.w("\ndefault: // %v %v", c.caseStr(), k)
			g.altCases(xs, out)
		default:
			g.w("\ncase %v: // %v", c.caseStr(), k)
			g.altCases(xs, out)
		}
	}
	if needDefault {
		g.w("\ndefault:%s", out)
	}
	g.w("\n}")
}

func (g *gen) altCases(x []ebnf.Expression, out string) {
	switch {
	case len(x) == 1:
		g.expression(x[0], out, false)
	default:
		for _, v := range x {
			next := g.id()
			g.expression(v, fmt.Sprintf("\ngoto _%d", next), false)
			g.w("\nbreak")
			g.w("\n_%d:", next)
		}
		g.w("%s", out)
	}
}
