package main

import (
	"bytes"
	"fmt"
	"go/token"
	"os"
	"sort"
	"strings"

	"golang.org/x/exp/ebnf"
	"modernc.org/mathutil"
)

func generate(dst, src string) error {
	g, err := newGen(dst, src)
	if err != nil {
		return err
	}

	return g.gen()
}

type gen struct {
	b   bytes.Buffer
	dst string
	peg *grammar

	nextID int
}

func newGen(dst, src string) (*gen, error) {
	peg, err := loadPEG(src)
	if err != nil {
		return nil, err
	}

	return &gen{dst: dst, peg: peg}, nil
}

func (g *gen) w(format string, args ...interface{}) { fmt.Fprintf(&g.b, format, args...) }

func (g *gen) id() (r int) { r = g.nextID; g.nextID++; return r }

func (g *gen) tok(s string) token.Token {
	if r, ok := toks[s]; ok {
		return r
	}

	panic(todo("%q", s))
}

func (g *gen) isToken(e ebnf.Expression, r *token.Token) bool {
	switch x := e.(type) {
	case *ebnf.Name:
		nm := x.String
		if token.IsExported(nm) {
			return g.isToken(g.peg.g[nm].Expr, r)
		}

		*r = g.tok(nm)
		return true
	case *ebnf.Token:
		*r = g.tok(x.String)
		return true
	default:
		return false
	}
}

func noPreBlock(nm string) string {
	const tag = "PreBlock"
	if strings.HasSuffix(nm, tag) {
		nm = nm[:len(nm)-len(tag)]
	}
	return nm
}

func (g *gen) gen() (err error) {
	defer func() {
		if e := recover(); e != nil {
			if err == nil {
				err = fmt.Errorf("%v", e)
			}
		}
		if err != nil {
			return
		}

		err = os.WriteFile(g.dst, g.b.Bytes(), 0660)
	}()

	// From https://golang.org/s/generatedcode (golang/go#13560 (comment));
	//
	// Generated files are marked by a line of text that matches the regular expression, in Go syntax:
	//
	//     ^// Code generated .* DO NOT EDIT\.$
	//

	g.w("// Code generated by '$ go test -gen -run TestGen' DO NOT EDIT.")
	g.w("\n\npackage main")
	var a []string
	for v := range g.peg.g {
		a = append(a, v)
	}
	sort.Strings(a)
	for _, nm := range a {
		g.nextID = 0
		p := g.peg.g[nm]
		if !token.IsExported(nm) {
			continue
		}

		if !strings.HasSuffix(nm, "PreBlock") {
			g.w("\n\n// %sNode represents the production", nm)
			g.w("\n//\n//\t%s = %s .", nm, ebnfString(p.Expr))
			g.w("\ntype %sNode struct{ noder }", nm)
		}
		g.w("\n\nfunc (p *parser) %s() Node {", unexport(nm))
		ctx := g.peg.productionFollowSets[p]
		if *oAssert && !ctx.hasEpsilon() {
			g.w("\nswitch p.c() {")
			g.w("\ncase %s:", ctx.caseStr())
			g.w("\ndefault:")
			g.w("\npanic(todo(``, p.c()))")
			g.w("\n}")
		}
		switch x := p.Expr.(type) {
		case nil:
			g.w("\nreturn &%sNode{}", noPreBlock(nm))
		case ebnf.Alternative:
			g.expression(ctx, x, "\nreturn nil", false)
			g.w("\nreturn &%sNode{}", noPreBlock(nm))
		// case *ebnf.Group:
		case *ebnf.Name:
			nm2 := x.String
			if token.IsExported(nm2) {
				g.w("\nreturn p.%s()", unexport(nm2))
				break
			}

			t := g.tok(nm2)
			g.w("\nif p.c() == %s {", tokSource(t))
			g.w("\np.ix++")
			g.w("\np.budget--")
			g.w("\nreturn &%sNode{}", noPreBlock(nm))
			g.w("\n}")
			g.w("\nreturn nil")
		case *ebnf.Option:
			g.expression(ctx, x, "\npanic(`internal error`)", false)
			g.w("\nreturn &%sNode{}", noPreBlock(nm))
		// case *ebnf.Repetition:
		case ebnf.Sequence:
			g.expression(ctx, x, "\nreturn nil", false)
			g.w("\nreturn &%sNode{}", noPreBlock(nm))
		case *ebnf.Token:
			t := g.tok(x.String)
			g.w("\nif p.c() == %s {", tokSource(t))
			g.w("\np.ix++")
			g.w("\np.budget--")
			g.w("\nreturn &%sNode{}", noPreBlock(nm))
			g.w("\n}")
			g.w("\nreturn nil")
		default:
			id := g.id()
			g.w("\nix := p.ix")
			l := g.expression(ctx, x, fmt.Sprintf("\ngoto _%d", id), false)
			g.w("\nreturn &%sNode{}", noPreBlock(nm))
			if l {
				g.w("\n_%d:", id)
				g.w("\np.back(ix)")
				g.w("\nreturn nil")
			}
		}
		g.w("\n}")
	}
	return nil
}

func (g *gen) elsePart(out string) (r bool) {
	defer func() {
		if out == "" {
			r = false
		}
	}()

	if out != "" {
		g.w(" else {")
		g.w("%s", out)
		g.w("\n}")
		r = true
	}
	return r
}

func (g *gen) defaultPart(out string) (r bool) {
	defer func() {
		if out == "" {
			r = false
		}
	}()

	if out != "" {
		g.w("\n;default:%s", out)
		r = true
	}
	return r
}

// nil c -> unconstrained by caller
func (g *gen) expression(ctx followSet, e ebnf.Expression, out string, braced bool) (r bool) {
	defer func() {
		if out == "" {
			r = false
		}
	}()

	g.w("\n// %T %s ctx [%v]", e, ebnfString(e), ctx.caseStr())
	switch x := e.(type) {
	case ebnf.Alternative:
		c := g.peg.followSet(x)
		if len(ctx) != 0 {
			c = c.intersect(ctx)
		}
		return g.alt(c, x, out)
	case *ebnf.Group:
		c := g.peg.followSet(x.Body)
		if len(ctx) != 0 {
			c = c.intersect(ctx)
		}
		return g.expression(c, x.Body, out, false)
	case *ebnf.Name:
		nm := x.String
		if token.IsExported(nm) {
			switch p := g.peg.g[nm]; {
			case p.Expr == nil:
				g.w("\nif p.%s() == nil {", unexport(nm))
				g.w("%s", out)
				g.w("\n}")
			default:
				c := g.peg.productionFollowSets[p]
				if len(ctx) != 0 {
					c = c.intersect(ctx)
				}
				switch {
				case len(ctx) != 0 && ctx.isSubsetOf(c):
					g.w("\nif p.%s() == nil {", unexport(nm))
					g.w("%s", out)
					g.w("\n}")
				default:
					g.w("\nswitch p.c() {")
					g.w("\ncase %v:", c.caseStr())
					g.w("\nif p.%s() == nil {", unexport(nm))
					g.w("%s", out)
					g.w("\n}")
					if !c.hasEpsilon() {
						g.defaultPart(out)
					}
					g.w("\n}")
				}
			}
			return true
		}

		t := g.tok(x.String)
		if ctx.has(t) {
			g.w("\np.expect(%s)", tokSource(t))
			return false
		}

		g.w("\nif !p.accept(%s) {", tokSource(t))
		g.w("%s", out)
		g.w("\n}")
		return true
	case *ebnf.Option:
		c := g.peg.followSet(x.Body)
		if len(ctx) != 0 {
			c = c.intersect(ctx)
		}
		switch {
		case len(ctx) != 0 && ctx.isSubsetOf(c):
			return g.expression(c, x.Body, "", false)
		default:
			g.w("\nswitch p.c() {")
			g.w("\ncase %v:", c.caseStr())
			ok := g.id()
			l := g.expression(c, x.Body, fmt.Sprintf("\ngoto _%d", ok), false)
			g.w("\n}")
			if l {
				g.w("\n_%[1]d:", ok)
			}
			return false
		}
	case *ebnf.Repetition:
		//TODO? specialize for single item .Body
		c := g.peg.followSet(x.Body)
		if len(ctx) != 0 {
			c = c.intersect(ctx)
		}
		switch {
		case len(ctx) != 0 && ctx.isSubsetOf(c):
			id := g.id()
			g.w("\n_%d:", id)
			ok := g.id()
			l := g.expression(c, x.Body, fmt.Sprintf("\ngoto _%d", ok), true)
			if l {
				g.w("\n_%[1]d:", ok)
			}
		default:
			id := g.id()
			g.w("\n_%d:", id)
			ok := g.id()
			g.w("\nswitch p.c() {")
			g.w("\ncase %v:", c.caseStr())
			l := g.expression(c, x.Body, fmt.Sprintf("\ngoto _%d", ok), true)
			g.w("\ngoto _%d", id)
			g.w("\n}")
			if l {
				g.w("\n_%[1]d:", ok)
			}
		}
		return false
	case ebnf.Sequence:
		var t token.Token
		hasToken := false
		for _, v := range x {
			if g.isToken(v, &t) {
				hasToken = true
				break
			}
		}
		out2 := out
		if !strings.Contains(out, "p.back(ix)") {
			out2 = fmt.Sprintf("\np.back(ix);%s", out)
		}
		var ctx2 followSet
		switch {
		case braced:
			ctx2, r = g.sequenceFilter(x, out)
			if hasToken {
				g.w("\nix := p.ix")
				if ctx != nil {
					g.w("\n_ = ix")
				}
			}
			for _, v := range x {
				if g.expression(ctx, v, out2, false) {
					r = true
				}
				ctx = ctx2
				ctx2 = nil
			}
		default:
			g.w("\n{")
			ctx2, r = g.sequenceFilter(x, out)
			g.w("\nix := p.ix")
			if ctx != nil {
				g.w("\n_ = ix")
			}
			for _, v := range x {
				if g.expression(ctx, v, out2, false) {
					r = true
				}
				ctx = ctx2
				ctx2 = nil
			}
			g.w("\n}")
		}
		return r
	case *ebnf.Token:
		switch t := g.tok(x.String); {
		case t == epsilon:
			panic(todo(""))
		case ctx.has(t):
			g.w("\np.expect(%s)", tokSource(t))
			return false
		default:
			g.w("\nif !p.accept(%s) {", tokSource(t))
			g.w("%s", out)
			g.w("\n}")
			return true
		}
	default:
		g.w("\n//TODO %T: '%s'", x, ebnfString(e))
		g.w("%s", out)
		return true
	}
}

func (g *gen) sequenceFilter(x ebnf.Sequence, out string) (fs followSet, r bool) {
	defer func() {
		if out == "" {
			r = false
		}
	}()

	var t0, t1 token.Token
	if len(x) < 2 || !g.isToken(x[0], &t0) {
		return nil, false
	}

	switch {
	case g.isToken(x[1], &t1):
		g.w("\nif p.peek(1) != %s {", tokSource(t1))
		g.w("%s", out)
		g.w("\n}")
		return followSet{t1: {}}, true
	default:
		fs := g.peg.followSet(x[1])
		if fs.hasEpsilon() {
			return nil, false
		}

		g.w("\nswitch p.peek(1) {")
		g.w("\ncase %s:", fs.caseStr())
		g.defaultPart(out)
		g.w("\n}")
		return fs, true
	}
}

func (g *gen) alt(ctx followSet, x ebnf.Alternative, out string) (r bool) {
	defer func() {
		if out == "" {
			r = false
		}
	}()

	m := map[token.Token][]int{}
	for i, v := range x {
		c := g.peg.followSet(v).clone()
		if len(ctx) != 0 {
			c = c.intersect(ctx)
		}
		for k := range c {
			m[k] = append(m[k], i)
		}
	}
	var mX []token.Token
	for k := range m {
		mX = append(mX, k)
	}
	sort.Slice(mX, func(i, j int) bool { return mX[i] < mX[j] })
	disjoint := map[string]followSet{}
	for _, t := range mX {
		is := m[t]
		if len(is) == 0 {
			continue
		}

		k := fmt.Sprint(is)
		k = k[1 : len(k)-1]
		c := disjoint[k]
		c.add(t)
		disjoint[k] = c
	}
	var disjointX []string
	for k := range disjoint {
		disjointX = append(disjointX, k)
	}
	sort.Slice(disjointX, func(i, j int) bool {
		a := ints(disjointX[i])
		b := ints(disjointX[j])
		for k := range a[:mathutil.Min(len(a), len(b))] {
			if a[k] < b[k] {
				return true
			}

			if a[k] > b[k] {
				return false
			}
		}
		return len(a) < len(b)
	})
	// for _, v := range disjointX {
	// 	g.w("\n// case %v: %v", disjoint[v].caseStr(), v)
	// }
	g.w("\nswitch p.c() {")
	needDefault := true
	for _, k := range disjointX {
		c := disjoint[k]
		if c.hasEpsilon() {
			needDefault = false
		}
		var xs []ebnf.Expression
		for _, v := range ints(k) {
			xs = append(xs, x[v])
		}
		switch {
		case len(c) == 1 && c.hasEpsilon():
			g.w("\ndefault: // %v %v", c.caseStr(), k)
			r = g.altCases(c, xs, out)
		default:
			g.w("\ncase %v: // %v", c.caseStr(), k)
			r = g.altCases(c, xs, out)
		}
	}
	if needDefault {
		g.w("\ndefault:%s", out)
		r = true
	}
	g.w("\n}")
	return r
}

func (g *gen) altCases(c followSet, x []ebnf.Expression, out string) (r bool) {
	defer func() {
		if out == "" {
			r = false
		}
	}()

	switch {
	case len(x) == 1:
		return g.expression(c, x[0], out, false)
	default:
		for _, v := range x {
			next := g.id()
			l := g.expression(c, v, fmt.Sprintf("\ngoto _%d", next), false)
			g.w("\nbreak")
			if l {
				g.w("\n_%d:", next)
			}
		}
		g.w("%s", out)
		r = true
	}
	return r
}
