package main

import (
	"bytes"
	"fmt"
	"go/token"
	"os"
	"sort"

	"golang.org/x/exp/ebnf"
)

func generate(dst, src string) error {
	g, err := newGen(dst, src)
	if err != nil {
		return err
	}

	return g.gen()
}

type gen struct {
	b   bytes.Buffer
	dst string
	peg *grammar

	nextID int
}

func newGen(dst, src string) (*gen, error) {
	peg, err := loadPEG(src)
	if err != nil {
		return nil, err
	}

	return &gen{dst: dst, peg: peg}, nil
}

func (g *gen) w(format string, args ...interface{}) { fmt.Fprintf(&g.b, format, args...) }

func (g *gen) id() (r int) { r = g.nextID; g.nextID++; return r }

func (g *gen) tok(s string) token.Token {
	if r, ok := toks[s]; ok {
		return r
	}

	panic(todo("%q", s))
}

func (g *gen) gen() (err error) {
	defer func() {
		if e := recover(); e != nil {
			if err == nil {
				err = fmt.Errorf("%v", e)
			}
		}
		if err != nil {
			return
		}

		err = os.WriteFile(g.dst, g.b.Bytes(), 0660)
	}()

	// From https://golang.org/s/generatedcode (golang/go#13560 (comment));
	//
	// Generated files are marked by a line of text that matches the regular expression, in Go syntax:
	//
	//     ^// Code generated .* DO NOT EDIT\.$
	//

	g.w("// Code generated by '$ go test -gen -run TestGen' DO NOT EDIT.")
	g.w("\n\npackage main")
	var a []string
	for v := range g.peg.g {
		a = append(a, v)
	}
	sort.Strings(a)
	for _, nm := range a {
		g.nextID = 0
		p := g.peg.g[nm]
		if !token.IsExported(nm) {
			continue
		}

		g.w("\n\n// %sNode represents", nm)
		g.w("\n\n//\t%s = %s .", nm, ebnfString(p.Expr))
		g.w("\ntype %sNode = struct{}", nm)
		g.w("\n\nfunc (p *parser) %s() *%sNode {", unexport(nm), nm)
		if p.Expr == nil {
			g.w("\nreturn &%sNode{}", nm)
			g.w("\n}")
			continue
		}

		id := g.id()
		g.w("\nix := p.ix")
		g.expression(p.Expr, fmt.Sprintf("\ngoto _%d", id), false)
		g.w("\nreturn &%sNode{}", nm)
		g.w("\ngoto _%d", id)
		g.w("\n_%d:", id)
		g.w("\np.back(ix)")
		g.w("\nreturn nil")
		g.w("\n}")
	}
	return nil
}

func (g *gen) elsePart(out string) {
	if out != "" {
		g.w(" else {")
		g.w("%s", out)
		g.w("\n}")
	}
}

func (g *gen) defaultPart(out string) {
	if out != "" {
		g.w("\n;default:%s", out)
	}
}

func (g *gen) expression(e ebnf.Expression, out string, braced bool) {
	switch x := e.(type) {
	case ebnf.Alternative:
		// //TODO use closures
		// ok := g.id()
		// g.w("\n// %T: %s", x, ebnfString(x))
		// g.w("\n{")
		// for _, v := range x {
		// 	next := g.id()
		// 	g.expression(v, fmt.Sprintf("\ngoto _%d", next), false)
		// 	g.w("\ngoto _%d", ok)
		// 	g.w("\n_%d:", next)
		// }
		// g.w("%s", out)
		// g.w("\n}")
		// g.w("\n_%d:", ok)
		g.alt(x, out)
	case *ebnf.Group:
		g.w("\n// %T: %s", x, ebnfString(x))
		c := g.peg.exprClosure(x.Body)
		g.w("\nswitch p.c().tok {")
		g.w("\ncase %v:", c.caseStr())
		g.expression(x.Body, out, false)
		if !c.hasEpsilon() {
			g.defaultPart(out)
		}
		g.w("\n}")
	case *ebnf.Name:
		nm := x.String
		if token.IsExported(nm) {
			p := g.peg.g[nm]
			c := g.peg.productClosures[p]
			switch p := g.peg.g[nm]; {
			case p.Expr == nil:
				g.w("\nif p.%s() == nil {", unexport(nm))
				g.w("%s", out)
				g.w("\n}")
			default:
				g.w("\nswitch p.c().tok {")
				g.w("\ncase %v:", c.caseStr())
				g.w("\nif p.%s() == nil {", unexport(nm))
				g.w("%s", out)
				g.w("\n}")
				if !c.hasEpsilon() {
					g.defaultPart(out)
				}
				g.w("\n}")
			}
			break
		}

		g.w("\nif p.c().tok == %s {", tokSource(g.tok(x.String)))
		g.w("\np.ix++")
		g.w("\np.budget--")
		g.w("\n}")
		g.elsePart(out)
	case *ebnf.Option:
		c := g.peg.exprClosure(x.Body)
		g.w("\n// %T: %s", x, ebnfString(x))
		g.w("\nswitch p.c().tok {")
		g.w("\ncase %v:", c.caseStr())
		ok := g.id()
		g.expression(x.Body, fmt.Sprintf("\ngoto _%d", ok), false)
		g.w("\n}")
		g.w("\n_%d:", ok)
	case *ebnf.Repetition:
		//TODO? specialize for single item .Body
		c := g.peg.exprClosure(x.Body)
		id := g.id()
		g.w("\n_%d:", id)
		ok := g.id()
		g.w("\n// %T: %s", x, ebnfString(x))
		g.w("\nswitch p.c().tok {")
		g.w("\ncase %v:", c.caseStr())
		g.expression(x.Body, fmt.Sprintf("\ngoto _%d", ok), true)
		g.w("\ngoto _%d", id)
		g.w("\n}")
		g.w("\n_%d:", ok)
	case ebnf.Sequence:
		g.w("\n// %T: %s", x, ebnfString(x))
		switch {
		case braced:
			g.w("\nix := p.ix")
			for _, v := range x {
				g.expression(v, fmt.Sprintf("\np.back(ix);%s", out), false)
			}
		default:
			g.w("\n{")
			g.w("\nix := p.ix")
			for _, v := range x {
				g.expression(v, fmt.Sprintf("\np.back(ix);%s", out), false)
			}
			g.w("\n}")
		}
	case *ebnf.Token:
		g.w("\nif p.c().tok == %s {", tokSource(g.tok(x.String)))
		g.w("\np.ix++")
		g.w("\np.budget--")
		g.w("\n}")
		g.elsePart(out)
	default:
		g.w("\n//TODO %T: '%s'", x, ebnfString(e))
		g.w("%s", out)
	}
}

func (g *gen) alt(x ebnf.Alternative, out string) {
	var cs []closure
	var oks []bool
	m := map[token.Token]int{}
	for _, v := range x {
		c := g.peg.exprClosure(v)
		cs = append(cs, c)
		for k := range c {
			m[k]++
		}
	}
next:
	for _, v := range cs {
		for k := range v {
			if m[k] > 1 {
				oks = append(oks, false)
				continue next
			}
		}
		oks = append(oks, true)
	}
	for i, v := range cs {
		g.w("\n// %v: %v", oks[i], v.caseStr())
	}
	single := closure{}
	multi := closure{}
	for k, v := range m {
		switch v {
		case 1:
			single.add(k)
		default:
			multi.add(k)
		}
	}
	g.w("\n// single: %v", single.caseStr())
	g.w("\n// multi: %v", multi.caseStr())

	ok := g.id()
	g.w("\n// %T: %s", x, ebnfString(x))
	g.w("\n{")
	for _, v := range x {
		next := g.id()
		g.expression(v, fmt.Sprintf("\ngoto _%d", next), false)
		g.w("\ngoto _%d", ok)
		g.w("\n_%d:", next)
	}
	g.w("%s", out)
	g.w("\n}")
	g.w("\n_%d:", ok)
}
