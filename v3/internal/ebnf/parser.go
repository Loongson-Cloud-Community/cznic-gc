// Code generated by '$ go test -gen -run TestGen' DO NOT EDIT.

package main

// AddOpNode represents
//
//	AddOp = "+" | "-" | "|" | "^" .
type AddOpNode = struct{ noder }

func (p *parser) addOp() *AddOpNode {
	ix := p.ix
	// ebnf.Alternative: "+" | "-" | "|" | "^"
	switch p.c().tok {
	case ADD: // 0
		if p.c().tok == ADD {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case SUB: // 1
		if p.c().tok == SUB {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case OR: // 2
		if p.c().tok == OR {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case XOR: // 3
		if p.c().tok == XOR {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &AddOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AdditiveExpressionNode represents
//
//	AdditiveExpression = MultiplicativeExpression { AddOp MultiplicativeExpression } .
type AdditiveExpressionNode = struct{ noder }

func (p *parser) additiveExpression() *AdditiveExpressionNode {
	ix := p.ix
	// ebnf.Sequence: MultiplicativeExpression { AddOp MultiplicativeExpression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.multiplicativeExpression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { AddOp MultiplicativeExpression }
		switch p.c().tok {
		case ADD, OR, SUB, XOR:
			// ebnf.Sequence: AddOp MultiplicativeExpression
			ix := p.ix
			switch p.c().tok {
			case ADD, OR, SUB, XOR:
				if p.addOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.multiplicativeExpression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &AdditiveExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AdditiveExpressionPreBlockNode represents
//
//	AdditiveExpressionPreBlock = MultiplicativeExpressionPreBlock { AddOp MultiplicativeExpressionPreBlock } .
type AdditiveExpressionPreBlockNode = struct{ noder }

func (p *parser) additiveExpressionPreBlock() *AdditiveExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: MultiplicativeExpressionPreBlock { AddOp MultiplicativeExpressionPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.multiplicativeExpressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { AddOp MultiplicativeExpressionPreBlock }
		switch p.c().tok {
		case ADD, OR, SUB, XOR:
			// ebnf.Sequence: AddOp MultiplicativeExpressionPreBlock
			ix := p.ix
			switch p.c().tok {
			case ADD, OR, SUB, XOR:
				if p.addOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.multiplicativeExpressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &AdditiveExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AliasDeclNode represents
//
//	AliasDecl = identifier "=" Type .
type AliasDeclNode = struct{ noder }

func (p *parser) aliasDecl() *AliasDeclNode {
	ix := p.ix
	// ebnf.Sequence: identifier "=" Type
	{
		ix := p.ix
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == ASSIGN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &AliasDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ArgumentsNode represents
//
//	Arguments = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
type ArgumentsNode = struct{ noder }

func (p *parser) arguments() *ArgumentsNode {
	ix := p.ix
	// ebnf.Sequence: "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")"
	{
		ix := p.ix
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// ebnf.Sequence: ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ]
			{
				ix := p.ix
				// *ebnf.Group: ( ExpressionList | Type [ "," ExpressionList ] )
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					// ebnf.Alternative: ExpressionList | Type [ "," ExpressionList ]
					switch p.c().tok {
					case ADD, AND, CHAR, FLOAT, IMAG, INT, NOT, STRING, SUB, XOR: // 0
						switch p.c().tok {
						case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
							if p.expressionList() == nil {
								p.back(ix)
								goto _1
							}
						default:
							p.back(ix)
							goto _1
						}
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT: // 0 1
						switch p.c().tok {
						case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
							if p.expressionList() == nil {
								goto _2
							}
						default:
							goto _2
						}
						break
					_2:
						// ebnf.Sequence: Type [ "," ExpressionList ]
						{
							ix := p.ix
							switch p.c().tok {
							case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
								if p.type1() == nil {
									p.back(ix)
									goto _3
								}
							default:
								p.back(ix)
								goto _3
							}
							// *ebnf.Option: [ "," ExpressionList ]
							switch p.c().tok {
							case COMMA:
								// ebnf.Sequence: "," ExpressionList
								{
									ix := p.ix
									if p.c().tok == COMMA {
										p.ix++
										p.budget--
									} else {
										p.back(ix)
										goto _4
									}
									switch p.c().tok {
									case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
										if p.expressionList() == nil {
											p.back(ix)
											goto _4
										}
									default:
										p.back(ix)
										goto _4
									}
								}
							}
						_4:
						}
						break
					_3:
						p.back(ix)
						goto _1
					default:
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
				// *ebnf.Option: [ "..." ]
				switch p.c().tok {
				case ELLIPSIS:
					if p.c().tok == ELLIPSIS {
						p.ix++
						p.budget--
					} else {
						goto _5
					}
				}
			_5:
				// *ebnf.Option: [ "," ]
				switch p.c().tok {
				case COMMA:
					if p.c().tok == COMMA {
						p.ix++
						p.budget--
					} else {
						goto _6
					}
				}
			_6:
			}
		}
	_1:
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &ArgumentsNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ArrayLengthNode represents
//
//	ArrayLength = Expression .
type ArrayLengthNode = struct{ noder }

func (p *parser) arrayLength() *ArrayLengthNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ArrayLengthNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ArrayTypeNode represents
//
//	ArrayType = "[" ArrayLength "]" ElementType .
type ArrayTypeNode = struct{ noder }

func (p *parser) arrayType() *ArrayTypeNode {
	ix := p.ix
	// ebnf.Sequence: "[" ArrayLength "]" ElementType
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.arrayLength() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.elementType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ArrayTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AssignOpNode represents
//
//	AssignOp = "=" | "+=" | "-=" | "|=" | "^=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "&^=" .
type AssignOpNode = struct{ noder }

func (p *parser) assignOp() *AssignOpNode {
	ix := p.ix
	// ebnf.Alternative: "=" | "+=" | "-=" | "|=" | "^=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "&^="
	switch p.c().tok {
	case ASSIGN: // 0
		if p.c().tok == ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case ADD_ASSIGN: // 1
		if p.c().tok == ADD_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case SUB_ASSIGN: // 2
		if p.c().tok == SUB_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case OR_ASSIGN: // 3
		if p.c().tok == OR_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case XOR_ASSIGN: // 4
		if p.c().tok == XOR_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case MUL_ASSIGN: // 5
		if p.c().tok == MUL_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case QUO_ASSIGN: // 6
		if p.c().tok == QUO_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case REM_ASSIGN: // 7
		if p.c().tok == REM_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case SHL_ASSIGN: // 8
		if p.c().tok == SHL_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case SHR_ASSIGN: // 9
		if p.c().tok == SHR_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case AND_ASSIGN: // 10
		if p.c().tok == AND_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case AND_NOT_ASSIGN: // 11
		if p.c().tok == AND_NOT_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &AssignOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AssignmentNode represents
//
//	Assignment = ExpressionList AssignOp ExpressionList .
type AssignmentNode = struct{ noder }

func (p *parser) assignment() *AssignmentNode {
	ix := p.ix
	// ebnf.Sequence: ExpressionList AssignOp ExpressionList
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD_ASSIGN, AND_ASSIGN, AND_NOT_ASSIGN, ASSIGN, MUL_ASSIGN, OR_ASSIGN, QUO_ASSIGN, REM_ASSIGN, SHL_ASSIGN, SHR_ASSIGN, SUB_ASSIGN, XOR_ASSIGN:
			if p.assignOp() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &AssignmentNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AssignmentPreBlockNode represents
//
//	AssignmentPreBlock = ExpressionList AssignOp ExpressionListPreBlock .
type AssignmentPreBlockNode = struct{ noder }

func (p *parser) assignmentPreBlock() *AssignmentPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: ExpressionList AssignOp ExpressionListPreBlock
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD_ASSIGN, AND_ASSIGN, AND_NOT_ASSIGN, ASSIGN, MUL_ASSIGN, OR_ASSIGN, QUO_ASSIGN, REM_ASSIGN, SHL_ASSIGN, SHR_ASSIGN, SUB_ASSIGN, XOR_ASSIGN:
			if p.assignOp() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionListPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &AssignmentPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// BaseTypeNode represents
//
//	BaseType = Type .
type BaseTypeNode = struct{ noder }

func (p *parser) baseType() *BaseTypeNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
		if p.type1() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &BaseTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// BasicLitNode represents
//
//	BasicLit = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
type BasicLitNode = struct{ noder }

func (p *parser) basicLit() *BasicLitNode {
	ix := p.ix
	// ebnf.Alternative: int_lit | float_lit | imaginary_lit | rune_lit | string_lit
	switch p.c().tok {
	case INT: // 0
		if p.c().tok == INT {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case FLOAT: // 1
		if p.c().tok == FLOAT {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case IMAG: // 2
		if p.c().tok == IMAG {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case CHAR: // 3
		if p.c().tok == CHAR {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case STRING: // 4
		if p.c().tok == STRING {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &BasicLitNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// BlockNode represents
//
//	Block = "{" StatementList "}" .
type BlockNode = struct{ noder }

func (p *parser) block() *BlockNode {
	ix := p.ix
	// ebnf.Sequence: "{" StatementList "}"
	{
		ix := p.ix
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statementList() == nil {
				p.back(ix)
				goto _0
			}
		}
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &BlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// BreakStmtNode represents
//
//	BreakStmt = "break" [ Label ] .
type BreakStmtNode = struct{ noder }

func (p *parser) breakStmt() *BreakStmtNode {
	ix := p.ix
	// ebnf.Sequence: "break" [ Label ]
	{
		ix := p.ix
		if p.c().tok == BREAK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Label ]
		switch p.c().tok {
		case IDENT:
			switch p.c().tok {
			case IDENT:
				if p.label() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &BreakStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ChannelNode represents
//
//	Channel = Expression .
type ChannelNode = struct{ noder }

func (p *parser) channel() *ChannelNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ChannelNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ChannelTypeNode represents
//
//	ChannelType = "<-" "chan" ElementType | "chan" "<-" ElementType | "chan" ElementType .
type ChannelTypeNode = struct{ noder }

func (p *parser) channelType() *ChannelTypeNode {
	ix := p.ix
	// ebnf.Alternative: "<-" "chan" ElementType | "chan" "<-" ElementType | "chan" ElementType
	switch p.c().tok {
	case ARROW: // 0
		// ebnf.Sequence: "<-" "chan" ElementType
		{
			ix := p.ix
			if p.c().tok == ARROW {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			if p.c().tok == CHAN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		}
	case CHAN: // 1 2
		// ebnf.Sequence: "chan" "<-" ElementType
		{
			ix := p.ix
			if p.c().tok == CHAN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			if p.c().tok == ARROW {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _1
				}
			default:
				p.back(ix)
				goto _1
			}
		}
		break
	_1:
		// ebnf.Sequence: "chan" ElementType
		{
			ix := p.ix
			if p.c().tok == CHAN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		break
	_2:
		goto _0
	default:
		goto _0
	}
	return &ChannelTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// CommCaseNode represents
//
//	CommCase = "case" ( SendStmt | RecvStmt ) | "default" .
type CommCaseNode = struct{ noder }

func (p *parser) commCase() *CommCaseNode {
	ix := p.ix
	// ebnf.Alternative: "case" ( SendStmt | RecvStmt ) | "default"
	switch p.c().tok {
	case CASE: // 0
		// ebnf.Sequence: "case" ( SendStmt | RecvStmt )
		{
			ix := p.ix
			if p.c().tok == CASE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			// *ebnf.Group: ( SendStmt | RecvStmt )
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				// ebnf.Alternative: SendStmt | RecvStmt
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR: // 0 1
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.sendStmt() == nil {
							goto _1
						}
					default:
						goto _1
					}
					break
				_1:
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.recvStmt() == nil {
							goto _2
						}
					default:
						goto _2
					}
					break
				_2:
					p.back(ix)
					goto _0
				default:
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		}
	case DEFAULT: // 1
		if p.c().tok == DEFAULT {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &CommCaseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// CommClauseNode represents
//
//	CommClause = CommCase ":" StatementList .
type CommClauseNode = struct{ noder }

func (p *parser) commClause() *CommClauseNode {
	ix := p.ix
	// ebnf.Sequence: CommCase ":" StatementList
	{
		ix := p.ix
		switch p.c().tok {
		case CASE, DEFAULT:
			if p.commCase() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == COLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statementList() == nil {
				p.back(ix)
				goto _0
			}
		}
	}
	return &CommClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// CompositeLitNode represents
//
//	CompositeLit = LiteralType LiteralValue .
type CompositeLitNode = struct{ noder }

func (p *parser) compositeLit() *CompositeLitNode {
	ix := p.ix
	// ebnf.Sequence: LiteralType LiteralValue
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT, LBRACK, MAP, STRUCT:
			if p.literalType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LBRACE:
			if p.literalValue() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &CompositeLitNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// CompositeLitPreBlockNode represents
//
//	CompositeLitPreBlock = LiteralTypePreBlock LiteralValue .
type CompositeLitPreBlockNode = struct{ noder }

func (p *parser) compositeLitPreBlock() *CompositeLitPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: LiteralTypePreBlock LiteralValue
	{
		ix := p.ix
		switch p.c().tok {
		case LBRACK, MAP, STRUCT:
			if p.literalTypePreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LBRACE:
			if p.literalValue() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &CompositeLitPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ConditionNode represents
//
//	Condition = Expression .
type ConditionNode = struct{ noder }

func (p *parser) condition() *ConditionNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ConditionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ConstDeclNode represents
//
//	ConstDecl = "const" ( ConstSpec | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")" ) .
type ConstDeclNode = struct{ noder }

func (p *parser) constDecl() *ConstDeclNode {
	ix := p.ix
	// ebnf.Sequence: "const" ( ConstSpec | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")" )
	{
		ix := p.ix
		if p.c().tok == CONST {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( ConstSpec | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")" )
		switch p.c().tok {
		case IDENT, LPAREN:
			// ebnf.Alternative: ConstSpec | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")"
			switch p.c().tok {
			case IDENT: // 0
				switch p.c().tok {
				case IDENT:
					if p.constSpec() == nil {
						p.back(ix)
						goto _0
					}
				default:
					p.back(ix)
					goto _0
				}
			case LPAREN: // 1
				// ebnf.Sequence: "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")"
				{
					ix := p.ix
					if p.c().tok == LPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
					// *ebnf.Option: [ ConstSpec { ";" ConstSpec } [ ";" ] ]
					switch p.c().tok {
					case IDENT:
						// ebnf.Sequence: ConstSpec { ";" ConstSpec } [ ";" ]
						{
							ix := p.ix
							switch p.c().tok {
							case IDENT:
								if p.constSpec() == nil {
									p.back(ix)
									goto _1
								}
							default:
								p.back(ix)
								goto _1
							}
						_2:
							// *ebnf.Repetition: { ";" ConstSpec }
							switch p.c().tok {
							case SEMICOLON:
								// ebnf.Sequence: ";" ConstSpec
								ix := p.ix
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									p.back(ix)
									goto _3
								}
								switch p.c().tok {
								case IDENT:
									if p.constSpec() == nil {
										p.back(ix)
										goto _3
									}
								default:
									p.back(ix)
									goto _3
								}
								goto _2
							}
						_3:
							// *ebnf.Option: [ ";" ]
							switch p.c().tok {
							case SEMICOLON:
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									goto _4
								}
							}
						_4:
						}
					}
				_1:
					if p.c().tok == RPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
				}
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ConstDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ConstSpecNode represents
//
//	ConstSpec = IdentifierList [ [ Type ] "=" ExpressionList ] .
type ConstSpecNode = struct{ noder }

func (p *parser) constSpec() *ConstSpecNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList [ [ Type ] "=" ExpressionList ]
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ [ Type ] "=" ExpressionList ]
		switch p.c().tok {
		case ARROW, ASSIGN, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			// ebnf.Sequence: [ Type ] "=" ExpressionList
			{
				ix := p.ix
				// *ebnf.Option: [ Type ]
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					switch p.c().tok {
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
						if p.type1() == nil {
							goto _2
						}
					default:
						goto _2
					}
				}
			_2:
				if p.c().tok == ASSIGN {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expressionList() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
			}
		}
	_1:
	}
	return &ConstSpecNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ContinueStmtNode represents
//
//	ContinueStmt = "continue" [ Label ] .
type ContinueStmtNode = struct{ noder }

func (p *parser) continueStmt() *ContinueStmtNode {
	ix := p.ix
	// ebnf.Sequence: "continue" [ Label ]
	{
		ix := p.ix
		if p.c().tok == CONTINUE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Label ]
		switch p.c().tok {
		case IDENT:
			switch p.c().tok {
			case IDENT:
				if p.label() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &ContinueStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ConversionNode represents
//
//	Conversion = Type "(" Expression [ "," ] ")" .
type ConversionNode = struct{ noder }

func (p *parser) conversion() *ConversionNode {
	ix := p.ix
	// ebnf.Sequence: Type "(" Expression [ "," ] ")"
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ "," ]
		switch p.c().tok {
		case COMMA:
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				goto _1
			}
		}
	_1:
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &ConversionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// DeclarationNode represents
//
//	Declaration = ConstDecl | TypeDecl | VarDecl .
type DeclarationNode = struct{ noder }

func (p *parser) declaration() *DeclarationNode {
	ix := p.ix
	// ebnf.Alternative: ConstDecl | TypeDecl | VarDecl
	switch p.c().tok {
	case CONST: // 0
		switch p.c().tok {
		case CONST:
			if p.constDecl() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case TYPE: // 1
		switch p.c().tok {
		case TYPE:
			if p.typeDecl() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case VAR: // 2
		switch p.c().tok {
		case VAR:
			if p.varDecl() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &DeclarationNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// DeferStmtNode represents
//
//	DeferStmt = "defer" Expression .
type DeferStmtNode = struct{ noder }

func (p *parser) deferStmt() *DeferStmtNode {
	ix := p.ix
	// ebnf.Sequence: "defer" Expression
	{
		ix := p.ix
		if p.c().tok == DEFER {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &DeferStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ElementNode represents
//
//	Element = Expression | LiteralValue .
type ElementNode = struct{ noder }

func (p *parser) element() *ElementNode {
	ix := p.ix
	// ebnf.Alternative: Expression | LiteralValue
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR: // 0
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case LBRACE: // 1
		switch p.c().tok {
		case LBRACE:
			if p.literalValue() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &ElementNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ElementListNode represents
//
//	ElementList = KeyedElement { "," KeyedElement } .
type ElementListNode = struct{ noder }

func (p *parser) elementList() *ElementListNode {
	ix := p.ix
	// ebnf.Sequence: KeyedElement { "," KeyedElement }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.keyedElement() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," KeyedElement }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," KeyedElement
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.keyedElement() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ElementListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ElementTypeNode represents
//
//	ElementType = Type .
type ElementTypeNode = struct{ noder }

func (p *parser) elementType() *ElementTypeNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
		if p.type1() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ElementTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// EmbeddedFieldNode represents
//
//	EmbeddedField = [ "*" ] TypeName [ TypeArgs ] .
type EmbeddedFieldNode = struct{ noder }

func (p *parser) embeddedField() *EmbeddedFieldNode {
	ix := p.ix
	// ebnf.Sequence: [ "*" ] TypeName [ TypeArgs ]
	{
		ix := p.ix
		// *ebnf.Option: [ "*" ]
		switch p.c().tok {
		case MUL:
			if p.c().tok == MUL {
				p.ix++
				p.budget--
			} else {
				goto _1
			}
		}
	_1:
		switch p.c().tok {
		case IDENT:
			if p.typeName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ TypeArgs ]
		switch p.c().tok {
		case LBRACK:
			switch p.c().tok {
			case LBRACK:
				if p.typeArgs() == nil {
					goto _2
				}
			default:
				goto _2
			}
		}
	_2:
	}
	return &EmbeddedFieldNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// EmptyStmtNode represents
//
//	EmptyStmt =  .
type EmptyStmtNode = struct{ noder }

func (p *parser) emptyStmt() *EmptyStmtNode {
	return &EmptyStmtNode{}
}

// ExprCaseClauseNode represents
//
//	ExprCaseClause = ExprSwitchCase ":" StatementList .
type ExprCaseClauseNode = struct{ noder }

func (p *parser) exprCaseClause() *ExprCaseClauseNode {
	ix := p.ix
	// ebnf.Sequence: ExprSwitchCase ":" StatementList
	{
		ix := p.ix
		switch p.c().tok {
		case CASE, DEFAULT:
			if p.exprSwitchCase() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == COLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statementList() == nil {
				p.back(ix)
				goto _0
			}
		}
	}
	return &ExprCaseClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExprSwitchCaseNode represents
//
//	ExprSwitchCase = "case" ExpressionList | "default" .
type ExprSwitchCaseNode = struct{ noder }

func (p *parser) exprSwitchCase() *ExprSwitchCaseNode {
	ix := p.ix
	// ebnf.Alternative: "case" ExpressionList | "default"
	switch p.c().tok {
	case CASE: // 0
		// ebnf.Sequence: "case" ExpressionList
		{
			ix := p.ix
			if p.c().tok == CASE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionList() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		}
	case DEFAULT: // 1
		if p.c().tok == DEFAULT {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &ExprSwitchCaseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExprSwitchStmtNode represents
//
//	ExprSwitchStmt = "switch" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}" | "switch" SimpleStmt ";" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}" .
type ExprSwitchStmtNode = struct{ noder }

func (p *parser) exprSwitchStmt() *ExprSwitchStmtNode {
	ix := p.ix
	// ebnf.Alternative: "switch" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}" | "switch" SimpleStmt ";" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}"
	switch p.c().tok {
	case SWITCH: // 0 1
		// ebnf.Sequence: "switch" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}"
		{
			ix := p.ix
			if p.c().tok == SWITCH {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			// *ebnf.Option: [ ExpressionPreBlock ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expressionPreBlock() == nil {
						goto _2
					}
				default:
					goto _2
				}
			}
		_2:
			if p.c().tok == LBRACE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
		_3:
			// *ebnf.Repetition: { ExprCaseClause }
			switch p.c().tok {
			case CASE, DEFAULT:
				switch p.c().tok {
				case CASE, DEFAULT:
					if p.exprCaseClause() == nil {
						goto _4
					}
				default:
					goto _4
				}
				goto _3
			}
		_4:
			if p.c().tok == RBRACE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
		}
		break
	_1:
		// ebnf.Sequence: "switch" SimpleStmt ";" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}"
		{
			ix := p.ix
			if p.c().tok == SWITCH {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
				if p.simpleStmt() == nil {
					p.back(ix)
					goto _5
				}
			}
			if p.c().tok == SEMICOLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			// *ebnf.Option: [ ExpressionPreBlock ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expressionPreBlock() == nil {
						goto _6
					}
				default:
					goto _6
				}
			}
		_6:
			if p.c().tok == LBRACE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
		_7:
			// *ebnf.Repetition: { ExprCaseClause }
			switch p.c().tok {
			case CASE, DEFAULT:
				switch p.c().tok {
				case CASE, DEFAULT:
					if p.exprCaseClause() == nil {
						goto _8
					}
				default:
					goto _8
				}
				goto _7
			}
		_8:
			if p.c().tok == RBRACE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
		}
		break
	_5:
		goto _0
	default:
		goto _0
	}
	return &ExprSwitchStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionNode represents
//
//	Expression = LogicalAndExpression { "||" LogicalAndExpression } .
type ExpressionNode = struct{ noder }

func (p *parser) expression() *ExpressionNode {
	ix := p.ix
	// ebnf.Sequence: LogicalAndExpression { "||" LogicalAndExpression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.logicalAndExpression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "||" LogicalAndExpression }
		switch p.c().tok {
		case LOR:
			// ebnf.Sequence: "||" LogicalAndExpression
			ix := p.ix
			if p.c().tok == LOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.logicalAndExpression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionListNode represents
//
//	ExpressionList = Expression { "," Expression } .
type ExpressionListNode = struct{ noder }

func (p *parser) expressionList() *ExpressionListNode {
	ix := p.ix
	// ebnf.Sequence: Expression { "," Expression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," Expression }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," Expression
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ExpressionListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionListPreBlockNode represents
//
//	ExpressionListPreBlock = ExpressionPreBlock { "," ExpressionPreBlock } .
type ExpressionListPreBlockNode = struct{ noder }

func (p *parser) expressionListPreBlock() *ExpressionListPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: ExpressionPreBlock { "," ExpressionPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," ExpressionPreBlock }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," ExpressionPreBlock
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ExpressionListPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionPreBlockNode represents
//
//	ExpressionPreBlock = LogicalAndExpressionPreBlock { "||" LogicalAndExpressionPreBlock } | Expression .
type ExpressionPreBlockNode = struct{ noder }

func (p *parser) expressionPreBlock() *ExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Alternative: LogicalAndExpressionPreBlock { "||" LogicalAndExpressionPreBlock } | Expression
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR: // 0 1
		// ebnf.Sequence: LogicalAndExpressionPreBlock { "||" LogicalAndExpressionPreBlock }
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.logicalAndExpressionPreBlock() == nil {
					p.back(ix)
					goto _1
				}
			default:
				p.back(ix)
				goto _1
			}
		_2:
			// *ebnf.Repetition: { "||" LogicalAndExpressionPreBlock }
			switch p.c().tok {
			case LOR:
				// ebnf.Sequence: "||" LogicalAndExpressionPreBlock
				ix := p.ix
				if p.c().tok == LOR {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _3
				}
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.logicalAndExpressionPreBlock() == nil {
						p.back(ix)
						goto _3
					}
				default:
					p.back(ix)
					goto _3
				}
				goto _2
			}
		_3:
		}
		break
	_1:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				goto _4
			}
		default:
			goto _4
		}
		break
	_4:
		goto _0
	default:
		goto _0
	}
	return &ExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionStmtNode represents
//
//	ExpressionStmt = Expression .
type ExpressionStmtNode = struct{ noder }

func (p *parser) expressionStmt() *ExpressionStmtNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ExpressionStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionStmtPreBlockNode represents
//
//	ExpressionStmtPreBlock = ExpressionPreBlock .
type ExpressionStmtPreBlockNode = struct{ noder }

func (p *parser) expressionStmtPreBlock() *ExpressionStmtPreBlockNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expressionPreBlock() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ExpressionStmtPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FallthroughStmtNode represents
//
//	FallthroughStmt = "fallthrough" .
type FallthroughStmtNode = struct{ noder }

func (p *parser) fallthroughStmt() *FallthroughStmtNode {
	ix := p.ix
	if p.c().tok == FALLTHROUGH {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &FallthroughStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FieldDeclNode represents
//
//	FieldDecl = ( IdentifierList Type | EmbeddedField ) [ Tag ] .
type FieldDeclNode = struct{ noder }

func (p *parser) fieldDecl() *FieldDeclNode {
	ix := p.ix
	// ebnf.Sequence: ( IdentifierList Type | EmbeddedField ) [ Tag ]
	{
		ix := p.ix
		// *ebnf.Group: ( IdentifierList Type | EmbeddedField )
		switch p.c().tok {
		case IDENT, MUL:
			// ebnf.Alternative: IdentifierList Type | EmbeddedField
			switch p.c().tok {
			case IDENT: // 0 1
				// ebnf.Sequence: IdentifierList Type
				{
					ix := p.ix
					switch p.c().tok {
					case IDENT:
						if p.identifierList() == nil {
							p.back(ix)
							goto _1
						}
					default:
						p.back(ix)
						goto _1
					}
					switch p.c().tok {
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
						if p.type1() == nil {
							p.back(ix)
							goto _1
						}
					default:
						p.back(ix)
						goto _1
					}
				}
				break
			_1:
				switch p.c().tok {
				case IDENT, MUL:
					if p.embeddedField() == nil {
						goto _2
					}
				default:
					goto _2
				}
				break
			_2:
				p.back(ix)
				goto _0
			case MUL: // 1
				switch p.c().tok {
				case IDENT, MUL:
					if p.embeddedField() == nil {
						p.back(ix)
						goto _0
					}
				default:
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Tag ]
		switch p.c().tok {
		case STRING:
			switch p.c().tok {
			case STRING:
				if p.tag() == nil {
					goto _3
				}
			default:
				goto _3
			}
		}
	_3:
	}
	return &FieldDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FieldNameNode represents
//
//	FieldName = identifier .
type FieldNameNode = struct{ noder }

func (p *parser) fieldName() *FieldNameNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &FieldNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ForClauseNode represents
//
//	ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
type ForClauseNode = struct{ noder }

func (p *parser) forClause() *ForClauseNode {
	ix := p.ix
	// ebnf.Sequence: [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ]
	{
		ix := p.ix
		// *ebnf.Option: [ InitStmt ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
				if p.initStmt() == nil {
					goto _1
				}
			}
		}
	_1:
		if p.c().tok == SEMICOLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Condition ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.condition() == nil {
					goto _2
				}
			default:
				goto _2
			}
		}
	_2:
		if p.c().tok == SEMICOLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ PostStmt ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
				if p.postStmt() == nil {
					goto _3
				}
			}
		}
	_3:
	}
	return &ForClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ForStmtNode represents
//
//	ForStmt = "for" ForClause Block | "for" RangeClause Block | "for" ExpressionPreBlock Block | "for" Block .
type ForStmtNode = struct{ noder }

func (p *parser) forStmt() *ForStmtNode {
	ix := p.ix
	// ebnf.Alternative: "for" ForClause Block | "for" RangeClause Block | "for" ExpressionPreBlock Block | "for" Block
	switch p.c().tok {
	case FOR: // 0 1 2 3
		// ebnf.Sequence: "for" ForClause Block
		{
			ix := p.ix
			if p.c().tok == FOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, SEMICOLON, STRING, STRUCT, SUB, XOR:
				if p.forClause() == nil {
					p.back(ix)
					goto _1
				}
			default:
				p.back(ix)
				goto _1
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _1
				}
			default:
				p.back(ix)
				goto _1
			}
		}
		break
	_1:
		// ebnf.Sequence: "for" RangeClause Block
		{
			ix := p.ix
			if p.c().tok == FOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, RANGE, STRING, STRUCT, SUB, XOR:
				if p.rangeClause() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		break
	_2:
		// ebnf.Sequence: "for" ExpressionPreBlock Block
		{
			ix := p.ix
			if p.c().tok == FOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionPreBlock() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
		}
		break
	_3:
		// ebnf.Sequence: "for" Block
		{
			ix := p.ix
			if p.c().tok == FOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
		}
		break
	_4:
		goto _0
	default:
		goto _0
	}
	return &ForStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionBodyNode represents
//
//	FunctionBody = Block .
type FunctionBodyNode = struct{ noder }

func (p *parser) functionBody() *FunctionBodyNode {
	ix := p.ix
	switch p.c().tok {
	case LBRACE:
		if p.block() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &FunctionBodyNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionDeclNode represents
//
//	FunctionDecl = "func" FunctionName [ TypeParameters ] Signature [ FunctionBody ] .
type FunctionDeclNode = struct{ noder }

func (p *parser) functionDecl() *FunctionDeclNode {
	ix := p.ix
	// ebnf.Sequence: "func" FunctionName [ TypeParameters ] Signature [ FunctionBody ]
	{
		ix := p.ix
		if p.c().tok == FUNC {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.functionName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ TypeParameters ]
		switch p.c().tok {
		case LBRACK:
			switch p.c().tok {
			case LBRACK:
				if p.typeParameters() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ FunctionBody ]
		switch p.c().tok {
		case LBRACE:
			switch p.c().tok {
			case LBRACE:
				if p.functionBody() == nil {
					goto _2
				}
			default:
				goto _2
			}
		}
	_2:
	}
	return &FunctionDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionLitNode represents
//
//	FunctionLit = "func" Signature FunctionBody .
type FunctionLitNode = struct{ noder }

func (p *parser) functionLit() *FunctionLitNode {
	ix := p.ix
	// ebnf.Sequence: "func" Signature FunctionBody
	{
		ix := p.ix
		if p.c().tok == FUNC {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LBRACE:
			if p.functionBody() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &FunctionLitNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionNameNode represents
//
//	FunctionName = identifier .
type FunctionNameNode = struct{ noder }

func (p *parser) functionName() *FunctionNameNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &FunctionNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionTypeNode represents
//
//	FunctionType = "func" Signature .
type FunctionTypeNode = struct{ noder }

func (p *parser) functionType() *FunctionTypeNode {
	ix := p.ix
	// ebnf.Sequence: "func" Signature
	{
		ix := p.ix
		if p.c().tok == FUNC {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &FunctionTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// GoStmtNode represents
//
//	GoStmt = "go" Expression .
type GoStmtNode = struct{ noder }

func (p *parser) goStmt() *GoStmtNode {
	ix := p.ix
	// ebnf.Sequence: "go" Expression
	{
		ix := p.ix
		if p.c().tok == GO {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &GoStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// GotoStmtNode represents
//
//	GotoStmt = "goto" Label .
type GotoStmtNode = struct{ noder }

func (p *parser) gotoStmt() *GotoStmtNode {
	ix := p.ix
	// ebnf.Sequence: "goto" Label
	{
		ix := p.ix
		if p.c().tok == GOTO {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.label() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &GotoStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// IdentifierListNode represents
//
//	IdentifierList = identifier { "," identifier } .
type IdentifierListNode = struct{ noder }

func (p *parser) identifierList() *IdentifierListNode {
	ix := p.ix
	// ebnf.Sequence: identifier { "," identifier }
	{
		ix := p.ix
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," identifier }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," identifier
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			if p.c().tok == IDENT {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &IdentifierListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// IfStmtNode represents
//
//	IfStmt = "if" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ] | "if" SimpleStmt ";" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ] .
type IfStmtNode = struct{ noder }

func (p *parser) ifStmt() *IfStmtNode {
	ix := p.ix
	// ebnf.Alternative: "if" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ] | "if" SimpleStmt ";" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ]
	switch p.c().tok {
	case IF: // 0 1
		// ebnf.Sequence: "if" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ]
		{
			ix := p.ix
			if p.c().tok == IF {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionPreBlock() == nil {
					p.back(ix)
					goto _1
				}
			default:
				p.back(ix)
				goto _1
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _1
				}
			default:
				p.back(ix)
				goto _1
			}
			// *ebnf.Option: [ "else" ( IfStmt | Block ) ]
			switch p.c().tok {
			case ELSE:
				// ebnf.Sequence: "else" ( IfStmt | Block )
				{
					ix := p.ix
					if p.c().tok == ELSE {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _2
					}
					// *ebnf.Group: ( IfStmt | Block )
					switch p.c().tok {
					case IF, LBRACE:
						// ebnf.Alternative: IfStmt | Block
						switch p.c().tok {
						case IF: // 0
							switch p.c().tok {
							case IF:
								if p.ifStmt() == nil {
									p.back(ix)
									goto _2
								}
							default:
								p.back(ix)
								goto _2
							}
						case LBRACE: // 1
							switch p.c().tok {
							case LBRACE:
								if p.block() == nil {
									p.back(ix)
									goto _2
								}
							default:
								p.back(ix)
								goto _2
							}
						default:
							p.back(ix)
							goto _2
						}
					default:
						p.back(ix)
						goto _2
					}
				}
			}
		_2:
		}
		break
	_1:
		// ebnf.Sequence: "if" SimpleStmt ";" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ]
		{
			ix := p.ix
			if p.c().tok == IF {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
				if p.simpleStmt() == nil {
					p.back(ix)
					goto _3
				}
			}
			if p.c().tok == SEMICOLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionPreBlock() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
			// *ebnf.Option: [ "else" ( IfStmt | Block ) ]
			switch p.c().tok {
			case ELSE:
				// ebnf.Sequence: "else" ( IfStmt | Block )
				{
					ix := p.ix
					if p.c().tok == ELSE {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _4
					}
					// *ebnf.Group: ( IfStmt | Block )
					switch p.c().tok {
					case IF, LBRACE:
						// ebnf.Alternative: IfStmt | Block
						switch p.c().tok {
						case IF: // 0
							switch p.c().tok {
							case IF:
								if p.ifStmt() == nil {
									p.back(ix)
									goto _4
								}
							default:
								p.back(ix)
								goto _4
							}
						case LBRACE: // 1
							switch p.c().tok {
							case LBRACE:
								if p.block() == nil {
									p.back(ix)
									goto _4
								}
							default:
								p.back(ix)
								goto _4
							}
						default:
							p.back(ix)
							goto _4
						}
					default:
						p.back(ix)
						goto _4
					}
				}
			}
		_4:
		}
		break
	_3:
		goto _0
	default:
		goto _0
	}
	return &IfStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ImportDeclNode represents
//
//	ImportDecl = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
type ImportDeclNode = struct{ noder }

func (p *parser) importDecl() *ImportDeclNode {
	ix := p.ix
	// ebnf.Sequence: "import" ( ImportSpec | "(" { ImportSpec ";" } ")" )
	{
		ix := p.ix
		if p.c().tok == IMPORT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( ImportSpec | "(" { ImportSpec ";" } ")" )
		switch p.c().tok {
		case IDENT, LPAREN, PERIOD, STRING:
			// ebnf.Alternative: ImportSpec | "(" { ImportSpec ";" } ")"
			switch p.c().tok {
			case IDENT, PERIOD, STRING: // 0
				switch p.c().tok {
				case IDENT, PERIOD, STRING:
					if p.importSpec() == nil {
						p.back(ix)
						goto _0
					}
				default:
					p.back(ix)
					goto _0
				}
			case LPAREN: // 1
				// ebnf.Sequence: "(" { ImportSpec ";" } ")"
				{
					ix := p.ix
					if p.c().tok == LPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
				_1:
					// *ebnf.Repetition: { ImportSpec ";" }
					switch p.c().tok {
					case IDENT, PERIOD, STRING:
						// ebnf.Sequence: ImportSpec ";"
						ix := p.ix
						switch p.c().tok {
						case IDENT, PERIOD, STRING:
							if p.importSpec() == nil {
								p.back(ix)
								goto _2
							}
						default:
							p.back(ix)
							goto _2
						}
						if p.c().tok == SEMICOLON {
							p.ix++
							p.budget--
						} else {
							p.back(ix)
							goto _2
						}
						goto _1
					}
				_2:
					if p.c().tok == RPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
				}
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ImportDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ImportPathNode represents
//
//	ImportPath = string_lit .
type ImportPathNode = struct{ noder }

func (p *parser) importPath() *ImportPathNode {
	ix := p.ix
	if p.c().tok == STRING {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &ImportPathNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ImportSpecNode represents
//
//	ImportSpec = [ "." | PackageName ] ImportPath .
type ImportSpecNode = struct{ noder }

func (p *parser) importSpec() *ImportSpecNode {
	ix := p.ix
	// ebnf.Sequence: [ "." | PackageName ] ImportPath
	{
		ix := p.ix
		// *ebnf.Option: [ "." | PackageName ]
		switch p.c().tok {
		case IDENT, PERIOD:
			// ebnf.Alternative: "." | PackageName
			switch p.c().tok {
			case PERIOD: // 0
				if p.c().tok == PERIOD {
					p.ix++
					p.budget--
				} else {
					goto _1
				}
			case IDENT: // 1
				switch p.c().tok {
				case IDENT:
					if p.packageName() == nil {
						goto _1
					}
				default:
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
		switch p.c().tok {
		case STRING:
			if p.importPath() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ImportSpecNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// IncDecStmtNode represents
//
//	IncDecStmt = Expression ( "++" | "--" ) .
type IncDecStmtNode = struct{ noder }

func (p *parser) incDecStmt() *IncDecStmtNode {
	ix := p.ix
	// ebnf.Sequence: Expression ( "++" | "--" )
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( "++" | "--" )
		switch p.c().tok {
		case DEC, INC:
			// ebnf.Alternative: "++" | "--"
			switch p.c().tok {
			case INC: // 0
				if p.c().tok == INC {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _0
				}
			case DEC: // 1
				if p.c().tok == DEC {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &IncDecStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// IndexNode represents
//
//	Index = "[" Expression "]" .
type IndexNode = struct{ noder }

func (p *parser) index() *IndexNode {
	ix := p.ix
	// ebnf.Sequence: "[" Expression "]"
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &IndexNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// InitStmtNode represents
//
//	InitStmt = SimpleStmt .
type InitStmtNode = struct{ noder }

func (p *parser) initStmt() *InitStmtNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
		if p.simpleStmt() == nil {
			goto _0
		}
	}
	return &InitStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// InterfaceElemNode represents
//
//	InterfaceElem = MethodElem | TypeElem .
type InterfaceElemNode = struct{ noder }

func (p *parser) interfaceElem() *InterfaceElemNode {
	ix := p.ix
	// ebnf.Alternative: MethodElem | TypeElem
	switch p.c().tok {
	case IDENT: // 0 1
		switch p.c().tok {
		case IDENT:
			if p.methodElem() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			if p.typeElem() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		goto _0
	case ARROW, CHAN, FUNC, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE: // 1
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			if p.typeElem() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &InterfaceElemNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// InterfaceTypeNode represents
//
//	InterfaceType = "interface" "{" [ InterfaceElem { ";" InterfaceElem } [ ";" ] ] "}" .
type InterfaceTypeNode = struct{ noder }

func (p *parser) interfaceType() *InterfaceTypeNode {
	ix := p.ix
	// ebnf.Sequence: "interface" "{" [ InterfaceElem { ";" InterfaceElem } [ ";" ] ] "}"
	{
		ix := p.ix
		if p.c().tok == INTERFACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ InterfaceElem { ";" InterfaceElem } [ ";" ] ]
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			// ebnf.Sequence: InterfaceElem { ";" InterfaceElem } [ ";" ]
			{
				ix := p.ix
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
					if p.interfaceElem() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
			_2:
				// *ebnf.Repetition: { ";" InterfaceElem }
				switch p.c().tok {
				case SEMICOLON:
					// ebnf.Sequence: ";" InterfaceElem
					ix := p.ix
					if p.c().tok == SEMICOLON {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
					switch p.c().tok {
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
						if p.interfaceElem() == nil {
							p.back(ix)
							goto _3
						}
					default:
						p.back(ix)
						goto _3
					}
					goto _2
				}
			_3:
				// *ebnf.Option: [ ";" ]
				switch p.c().tok {
				case SEMICOLON:
					if p.c().tok == SEMICOLON {
						p.ix++
						p.budget--
					} else {
						goto _4
					}
				}
			_4:
			}
		}
	_1:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &InterfaceTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// KeyNode represents
//
//	Key = Expression | FieldName | LiteralValue .
type KeyNode = struct{ noder }

func (p *parser) key() *KeyNode {
	ix := p.ix
	// ebnf.Alternative: Expression | FieldName | LiteralValue
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR: // 0
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case IDENT: // 0 1
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case IDENT:
			if p.fieldName() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		goto _0
	case LBRACE: // 2
		switch p.c().tok {
		case LBRACE:
			if p.literalValue() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &KeyNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// KeyTypeNode represents
//
//	KeyType = Type .
type KeyTypeNode = struct{ noder }

func (p *parser) keyType() *KeyTypeNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
		if p.type1() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &KeyTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// KeyedElementNode represents
//
//	KeyedElement = [ Key ":" ] Element .
type KeyedElementNode = struct{ noder }

func (p *parser) keyedElement() *KeyedElementNode {
	ix := p.ix
	// ebnf.Sequence: [ Key ":" ] Element
	{
		ix := p.ix
		// *ebnf.Option: [ Key ":" ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// ebnf.Sequence: Key ":"
			{
				ix := p.ix
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.key() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
				if p.c().tok == COLON {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
			}
		}
	_1:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.element() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &KeyedElementNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LabelNode represents
//
//	Label = identifier .
type LabelNode = struct{ noder }

func (p *parser) label() *LabelNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &LabelNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LabeledStmtNode represents
//
//	LabeledStmt = Label ":" Statement .
type LabeledStmtNode = struct{ noder }

func (p *parser) labeledStmt() *LabeledStmtNode {
	ix := p.ix
	// ebnf.Sequence: Label ":" Statement
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.label() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == COLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statement() == nil {
				p.back(ix)
				goto _0
			}
		}
	}
	return &LabeledStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralNode represents
//
//	Literal = BasicLit | CompositeLit | FunctionLit .
type LiteralNode = struct{ noder }

func (p *parser) literal() *LiteralNode {
	ix := p.ix
	// ebnf.Alternative: BasicLit | CompositeLit | FunctionLit
	switch p.c().tok {
	case CHAR, FLOAT, IMAG, INT, STRING: // 0
		switch p.c().tok {
		case CHAR, FLOAT, IMAG, INT, STRING:
			if p.basicLit() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case IDENT, LBRACK, MAP, STRUCT: // 1
		switch p.c().tok {
		case IDENT, LBRACK, MAP, STRUCT:
			if p.compositeLit() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case FUNC: // 2
		switch p.c().tok {
		case FUNC:
			if p.functionLit() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &LiteralNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralPreBlockNode represents
//
//	LiteralPreBlock = BasicLit | CompositeLitPreBlock | FunctionLit .
type LiteralPreBlockNode = struct{ noder }

func (p *parser) literalPreBlock() *LiteralPreBlockNode {
	ix := p.ix
	// ebnf.Alternative: BasicLit | CompositeLitPreBlock | FunctionLit
	switch p.c().tok {
	case CHAR, FLOAT, IMAG, INT, STRING: // 0
		switch p.c().tok {
		case CHAR, FLOAT, IMAG, INT, STRING:
			if p.basicLit() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case LBRACK, MAP, STRUCT: // 1
		switch p.c().tok {
		case LBRACK, MAP, STRUCT:
			if p.compositeLitPreBlock() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case FUNC: // 2
		switch p.c().tok {
		case FUNC:
			if p.functionLit() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &LiteralPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralTypeNode represents
//
//	LiteralType = StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType | TypeName [ TypeArgs ] .
type LiteralTypeNode = struct{ noder }

func (p *parser) literalType() *LiteralTypeNode {
	ix := p.ix
	// ebnf.Alternative: StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType | TypeName [ TypeArgs ]
	switch p.c().tok {
	case STRUCT: // 0
		switch p.c().tok {
		case STRUCT:
			if p.structType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case LBRACK: // 1 2 3
		switch p.c().tok {
		case LBRACK:
			if p.arrayType() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		// ebnf.Sequence: "[" "..." "]" ElementType
		{
			ix := p.ix
			if p.c().tok == LBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			if p.c().tok == ELLIPSIS {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			if p.c().tok == RBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		break
	_2:
		switch p.c().tok {
		case LBRACK:
			if p.sliceType() == nil {
				goto _3
			}
		default:
			goto _3
		}
		break
	_3:
		goto _0
	case MAP: // 4
		switch p.c().tok {
		case MAP:
			if p.mapType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case IDENT: // 5
		// ebnf.Sequence: TypeName [ TypeArgs ]
		{
			ix := p.ix
			switch p.c().tok {
			case IDENT:
				if p.typeName() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
			// *ebnf.Option: [ TypeArgs ]
			switch p.c().tok {
			case LBRACK:
				switch p.c().tok {
				case LBRACK:
					if p.typeArgs() == nil {
						goto _4
					}
				default:
					goto _4
				}
			}
		_4:
		}
	default:
		goto _0
	}
	return &LiteralTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralTypePreBlockNode represents
//
//	LiteralTypePreBlock = StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType .
type LiteralTypePreBlockNode = struct{ noder }

func (p *parser) literalTypePreBlock() *LiteralTypePreBlockNode {
	ix := p.ix
	// ebnf.Alternative: StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType
	switch p.c().tok {
	case STRUCT: // 0
		switch p.c().tok {
		case STRUCT:
			if p.structType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case LBRACK: // 1 2 3
		switch p.c().tok {
		case LBRACK:
			if p.arrayType() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		// ebnf.Sequence: "[" "..." "]" ElementType
		{
			ix := p.ix
			if p.c().tok == LBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			if p.c().tok == ELLIPSIS {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			if p.c().tok == RBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		break
	_2:
		switch p.c().tok {
		case LBRACK:
			if p.sliceType() == nil {
				goto _3
			}
		default:
			goto _3
		}
		break
	_3:
		goto _0
	case MAP: // 4
		switch p.c().tok {
		case MAP:
			if p.mapType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &LiteralTypePreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralValueNode represents
//
//	LiteralValue = "{" [ ElementList [ "," ] ] "}" .
type LiteralValueNode = struct{ noder }

func (p *parser) literalValue() *LiteralValueNode {
	ix := p.ix
	// ebnf.Sequence: "{" [ ElementList [ "," ] ] "}"
	{
		ix := p.ix
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ ElementList [ "," ] ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// ebnf.Sequence: ElementList [ "," ]
			{
				ix := p.ix
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.elementList() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
				// *ebnf.Option: [ "," ]
				switch p.c().tok {
				case COMMA:
					if p.c().tok == COMMA {
						p.ix++
						p.budget--
					} else {
						goto _2
					}
				}
			_2:
			}
		}
	_1:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &LiteralValueNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LogicalAndExpressionNode represents
//
//	LogicalAndExpression = RelationalExpression { "&&" RelationalExpression } .
type LogicalAndExpressionNode = struct{ noder }

func (p *parser) logicalAndExpression() *LogicalAndExpressionNode {
	ix := p.ix
	// ebnf.Sequence: RelationalExpression { "&&" RelationalExpression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.relationalExpression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "&&" RelationalExpression }
		switch p.c().tok {
		case LAND:
			// ebnf.Sequence: "&&" RelationalExpression
			ix := p.ix
			if p.c().tok == LAND {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.relationalExpression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &LogicalAndExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LogicalAndExpressionPreBlockNode represents
//
//	LogicalAndExpressionPreBlock = RelationalExpressionPreBlock { "&&" RelationalExpressionPreBlock } .
type LogicalAndExpressionPreBlockNode = struct{ noder }

func (p *parser) logicalAndExpressionPreBlock() *LogicalAndExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: RelationalExpressionPreBlock { "&&" RelationalExpressionPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.relationalExpressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "&&" RelationalExpressionPreBlock }
		switch p.c().tok {
		case LAND:
			// ebnf.Sequence: "&&" RelationalExpressionPreBlock
			ix := p.ix
			if p.c().tok == LAND {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.relationalExpressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &LogicalAndExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MapTypeNode represents
//
//	MapType = "map" "[" KeyType "]" ElementType .
type MapTypeNode = struct{ noder }

func (p *parser) mapType() *MapTypeNode {
	ix := p.ix
	// ebnf.Sequence: "map" "[" KeyType "]" ElementType
	{
		ix := p.ix
		if p.c().tok == MAP {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.keyType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.elementType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &MapTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MethodDeclNode represents
//
//	MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
type MethodDeclNode = struct{ noder }

func (p *parser) methodDecl() *MethodDeclNode {
	ix := p.ix
	// ebnf.Sequence: "func" Receiver MethodName Signature [ FunctionBody ]
	{
		ix := p.ix
		if p.c().tok == FUNC {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.receiver() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.methodName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ FunctionBody ]
		switch p.c().tok {
		case LBRACE:
			switch p.c().tok {
			case LBRACE:
				if p.functionBody() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &MethodDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MethodElemNode represents
//
//	MethodElem = MethodName Signature .
type MethodElemNode = struct{ noder }

func (p *parser) methodElem() *MethodElemNode {
	ix := p.ix
	// ebnf.Sequence: MethodName Signature
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.methodName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &MethodElemNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MethodExprNode represents
//
//	MethodExpr = ReceiverType "." MethodName .
type MethodExprNode = struct{ noder }

func (p *parser) methodExpr() *MethodExprNode {
	ix := p.ix
	// ebnf.Sequence: ReceiverType "." MethodName
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.receiverType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.methodName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &MethodExprNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MethodNameNode represents
//
//	MethodName = identifier .
type MethodNameNode = struct{ noder }

func (p *parser) methodName() *MethodNameNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &MethodNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MulOpNode represents
//
//	MulOp = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .
type MulOpNode = struct{ noder }

func (p *parser) mulOp() *MulOpNode {
	ix := p.ix
	// ebnf.Alternative: "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
	switch p.c().tok {
	case MUL: // 0
		if p.c().tok == MUL {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case QUO: // 1
		if p.c().tok == QUO {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case REM: // 2
		if p.c().tok == REM {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case SHL: // 3
		if p.c().tok == SHL {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case SHR: // 4
		if p.c().tok == SHR {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case AND: // 5
		if p.c().tok == AND {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case AND_NOT: // 6
		if p.c().tok == AND_NOT {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &MulOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MultiplicativeExpressionNode represents
//
//	MultiplicativeExpression = UnaryExpr { MulOp UnaryExpr } .
type MultiplicativeExpressionNode = struct{ noder }

func (p *parser) multiplicativeExpression() *MultiplicativeExpressionNode {
	ix := p.ix
	// ebnf.Sequence: UnaryExpr { MulOp UnaryExpr }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.unaryExpr() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { MulOp UnaryExpr }
		switch p.c().tok {
		case AND, AND_NOT, MUL, QUO, REM, SHL, SHR:
			// ebnf.Sequence: MulOp UnaryExpr
			ix := p.ix
			switch p.c().tok {
			case AND, AND_NOT, MUL, QUO, REM, SHL, SHR:
				if p.mulOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExpr() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &MultiplicativeExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MultiplicativeExpressionPreBlockNode represents
//
//	MultiplicativeExpressionPreBlock = UnaryExprPreBlockPreBlock { MulOp UnaryExprPreBlockPreBlock } .
type MultiplicativeExpressionPreBlockNode = struct{ noder }

func (p *parser) multiplicativeExpressionPreBlock() *MultiplicativeExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: UnaryExprPreBlockPreBlock { MulOp UnaryExprPreBlockPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.unaryExprPreBlockPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { MulOp UnaryExprPreBlockPreBlock }
		switch p.c().tok {
		case AND, AND_NOT, MUL, QUO, REM, SHL, SHR:
			// ebnf.Sequence: MulOp UnaryExprPreBlockPreBlock
			ix := p.ix
			switch p.c().tok {
			case AND, AND_NOT, MUL, QUO, REM, SHL, SHR:
				if p.mulOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExprPreBlockPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &MultiplicativeExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// OperandNode represents
//
//	Operand = Literal | OperandName [ TypeArgs ] | "(" Expression ")" .
type OperandNode = struct{ noder }

func (p *parser) operand() *OperandNode {
	ix := p.ix
	// ebnf.Alternative: Literal | OperandName [ TypeArgs ] | "(" Expression ")"
	switch p.c().tok {
	case CHAR, FLOAT, FUNC, IMAG, INT, LBRACK, MAP, STRING, STRUCT: // 0
		switch p.c().tok {
		case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, MAP, STRING, STRUCT:
			if p.literal() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case IDENT: // 0 1
		switch p.c().tok {
		case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, MAP, STRING, STRUCT:
			if p.literal() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		// ebnf.Sequence: OperandName [ TypeArgs ]
		{
			ix := p.ix
			switch p.c().tok {
			case IDENT:
				if p.operandName() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			// *ebnf.Option: [ TypeArgs ]
			switch p.c().tok {
			case LBRACK:
				switch p.c().tok {
				case LBRACK:
					if p.typeArgs() == nil {
						goto _3
					}
				default:
					goto _3
				}
			}
		_3:
		}
		break
	_2:
		goto _0
	case LPAREN: // 2
		// ebnf.Sequence: "(" Expression ")"
		{
			ix := p.ix
			if p.c().tok == LPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
			if p.c().tok == RPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
		}
	default:
		goto _0
	}
	return &OperandNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// OperandNameNode represents
//
//	OperandName = QualifiedIdent | identifier .
type OperandNameNode = struct{ noder }

func (p *parser) operandName() *OperandNameNode {
	ix := p.ix
	// ebnf.Alternative: QualifiedIdent | identifier
	switch p.c().tok {
	case IDENT: // 0 1
		switch p.c().tok {
		case IDENT:
			if p.qualifiedIdent() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			goto _2
		}
		break
	_2:
		goto _0
	default:
		goto _0
	}
	return &OperandNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// OperandPreBlockNode represents
//
//	OperandPreBlock = LiteralPreBlock | OperandName [ TypeArgs ] | "(" Expression ")" .
type OperandPreBlockNode = struct{ noder }

func (p *parser) operandPreBlock() *OperandPreBlockNode {
	ix := p.ix
	// ebnf.Alternative: LiteralPreBlock | OperandName [ TypeArgs ] | "(" Expression ")"
	switch p.c().tok {
	case CHAR, FLOAT, FUNC, IMAG, INT, LBRACK, MAP, STRING, STRUCT: // 0
		switch p.c().tok {
		case CHAR, FLOAT, FUNC, IMAG, INT, LBRACK, MAP, STRING, STRUCT:
			if p.literalPreBlock() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case IDENT: // 1
		// ebnf.Sequence: OperandName [ TypeArgs ]
		{
			ix := p.ix
			switch p.c().tok {
			case IDENT:
				if p.operandName() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
			// *ebnf.Option: [ TypeArgs ]
			switch p.c().tok {
			case LBRACK:
				switch p.c().tok {
				case LBRACK:
					if p.typeArgs() == nil {
						goto _1
					}
				default:
					goto _1
				}
			}
		_1:
		}
	case LPAREN: // 2
		// ebnf.Sequence: "(" Expression ")"
		{
			ix := p.ix
			if p.c().tok == LPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
			if p.c().tok == RPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
		}
	default:
		goto _0
	}
	return &OperandPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PackageClauseNode represents
//
//	PackageClause = "package" PackageName .
type PackageClauseNode = struct{ noder }

func (p *parser) packageClause() *PackageClauseNode {
	ix := p.ix
	// ebnf.Sequence: "package" PackageName
	{
		ix := p.ix
		if p.c().tok == PACKAGE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.packageName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &PackageClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PackageNameNode represents
//
//	PackageName = identifier .
type PackageNameNode = struct{ noder }

func (p *parser) packageName() *PackageNameNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &PackageNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ParameterDeclNode represents
//
//	ParameterDecl = identifier "..." Type | identifier Type | "..." Type | Type .
type ParameterDeclNode = struct{ noder }

func (p *parser) parameterDecl() *ParameterDeclNode {
	ix := p.ix
	// ebnf.Alternative: identifier "..." Type | identifier Type | "..." Type | Type
	switch p.c().tok {
	case IDENT: // 0 1 3
		// ebnf.Sequence: identifier "..." Type
		{
			ix := p.ix
			if p.c().tok == IDENT {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			if p.c().tok == ELLIPSIS {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _1
				}
			default:
				p.back(ix)
				goto _1
			}
		}
		break
	_1:
		// ebnf.Sequence: identifier Type
		{
			ix := p.ix
			if p.c().tok == IDENT {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		break
	_2:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				goto _3
			}
		default:
			goto _3
		}
		break
	_3:
		goto _0
	case ELLIPSIS: // 2
		// ebnf.Sequence: "..." Type
		{
			ix := p.ix
			if p.c().tok == ELLIPSIS {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		}
	case ARROW, CHAN, FUNC, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT: // 3
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &ParameterDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ParameterListNode represents
//
//	ParameterList = ParameterDecl { "," ParameterDecl } .
type ParameterListNode = struct{ noder }

func (p *parser) parameterList() *ParameterListNode {
	ix := p.ix
	// ebnf.Sequence: ParameterDecl { "," ParameterDecl }
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, ELLIPSIS, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.parameterDecl() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," ParameterDecl }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," ParameterDecl
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, ELLIPSIS, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.parameterDecl() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ParameterListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ParametersNode represents
//
//	Parameters = "(" [ ParameterList [ "," ] ] ")" .
type ParametersNode = struct{ noder }

func (p *parser) parameters() *ParametersNode {
	ix := p.ix
	// ebnf.Sequence: "(" [ ParameterList [ "," ] ] ")"
	{
		ix := p.ix
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ ParameterList [ "," ] ]
		switch p.c().tok {
		case ARROW, CHAN, ELLIPSIS, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			// ebnf.Sequence: ParameterList [ "," ]
			{
				ix := p.ix
				switch p.c().tok {
				case ARROW, CHAN, ELLIPSIS, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.parameterList() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
				// *ebnf.Option: [ "," ]
				switch p.c().tok {
				case COMMA:
					if p.c().tok == COMMA {
						p.ix++
						p.budget--
					} else {
						goto _2
					}
				}
			_2:
			}
		}
	_1:
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &ParametersNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PointerTypeNode represents
//
//	PointerType = "*" BaseType .
type PointerTypeNode = struct{ noder }

func (p *parser) pointerType() *PointerTypeNode {
	ix := p.ix
	// ebnf.Sequence: "*" BaseType
	{
		ix := p.ix
		if p.c().tok == MUL {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.baseType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &PointerTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PostStmtNode represents
//
//	PostStmt = SimpleStmtPreBlock .
type PostStmtNode = struct{ noder }

func (p *parser) postStmt() *PostStmtNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
		if p.simpleStmtPreBlock() == nil {
			goto _0
		}
	}
	return &PostStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PrimaryExprNode represents
//
//	PrimaryExpr = ( Operand | Conversion | MethodExpr ) { Selector | Index | Slice | TypeAssertion | Arguments } .
type PrimaryExprNode = struct{ noder }

func (p *parser) primaryExpr() *PrimaryExprNode {
	ix := p.ix
	// ebnf.Sequence: ( Operand | Conversion | MethodExpr ) { Selector | Index | Slice | TypeAssertion | Arguments }
	{
		ix := p.ix
		// *ebnf.Group: ( Operand | Conversion | MethodExpr )
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			// ebnf.Alternative: Operand | Conversion | MethodExpr
			switch p.c().tok {
			case CHAR, FLOAT, IMAG, INT, STRING: // 0
				switch p.c().tok {
				case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT:
					if p.operand() == nil {
						p.back(ix)
						goto _0
					}
				default:
					p.back(ix)
					goto _0
				}
			case FUNC, IDENT, LBRACK, LPAREN, MAP, STRUCT: // 0 1 2
				switch p.c().tok {
				case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT:
					if p.operand() == nil {
						goto _1
					}
				default:
					goto _1
				}
				break
			_1:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.conversion() == nil {
						goto _2
					}
				default:
					goto _2
				}
				break
			_2:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.methodExpr() == nil {
						goto _3
					}
				default:
					goto _3
				}
				break
			_3:
				p.back(ix)
				goto _0
			case ARROW, CHAN, INTERFACE, MUL: // 1 2
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.conversion() == nil {
						goto _4
					}
				default:
					goto _4
				}
				break
			_4:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.methodExpr() == nil {
						goto _5
					}
				default:
					goto _5
				}
				break
			_5:
				p.back(ix)
				goto _0
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_6:
		// *ebnf.Repetition: { Selector | Index | Slice | TypeAssertion | Arguments }
		switch p.c().tok {
		case LBRACK, LPAREN, PERIOD:
			// ebnf.Alternative: Selector | Index | Slice | TypeAssertion | Arguments
			switch p.c().tok {
			case PERIOD: // 0 3
				switch p.c().tok {
				case PERIOD:
					if p.selector() == nil {
						goto _8
					}
				default:
					goto _8
				}
				break
			_8:
				switch p.c().tok {
				case PERIOD:
					if p.typeAssertion() == nil {
						goto _9
					}
				default:
					goto _9
				}
				break
			_9:
				goto _7
			case LBRACK: // 1 2
				switch p.c().tok {
				case LBRACK:
					if p.index() == nil {
						goto _10
					}
				default:
					goto _10
				}
				break
			_10:
				switch p.c().tok {
				case LBRACK:
					if p.slice() == nil {
						goto _11
					}
				default:
					goto _11
				}
				break
			_11:
				goto _7
			case LPAREN: // 4
				switch p.c().tok {
				case LPAREN:
					if p.arguments() == nil {
						goto _7
					}
				default:
					goto _7
				}
			default:
				goto _7
			}
			goto _6
		}
	_7:
	}
	return &PrimaryExprNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PrimaryExprPreBlockNode represents
//
//	PrimaryExprPreBlock = ( OperandPreBlock | Conversion | MethodExpr ) { Selector | Index | Slice | TypeAssertion | Arguments } .
type PrimaryExprPreBlockNode = struct{ noder }

func (p *parser) primaryExprPreBlock() *PrimaryExprPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: ( OperandPreBlock | Conversion | MethodExpr ) { Selector | Index | Slice | TypeAssertion | Arguments }
	{
		ix := p.ix
		// *ebnf.Group: ( OperandPreBlock | Conversion | MethodExpr )
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			// ebnf.Alternative: OperandPreBlock | Conversion | MethodExpr
			switch p.c().tok {
			case CHAR, FLOAT, IMAG, INT, STRING: // 0
				switch p.c().tok {
				case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT:
					if p.operandPreBlock() == nil {
						p.back(ix)
						goto _0
					}
				default:
					p.back(ix)
					goto _0
				}
			case FUNC, IDENT, LBRACK, LPAREN, MAP, STRUCT: // 0 1 2
				switch p.c().tok {
				case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT:
					if p.operandPreBlock() == nil {
						goto _1
					}
				default:
					goto _1
				}
				break
			_1:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.conversion() == nil {
						goto _2
					}
				default:
					goto _2
				}
				break
			_2:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.methodExpr() == nil {
						goto _3
					}
				default:
					goto _3
				}
				break
			_3:
				p.back(ix)
				goto _0
			case ARROW, CHAN, INTERFACE, MUL: // 1 2
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.conversion() == nil {
						goto _4
					}
				default:
					goto _4
				}
				break
			_4:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.methodExpr() == nil {
						goto _5
					}
				default:
					goto _5
				}
				break
			_5:
				p.back(ix)
				goto _0
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_6:
		// *ebnf.Repetition: { Selector | Index | Slice | TypeAssertion | Arguments }
		switch p.c().tok {
		case LBRACK, LPAREN, PERIOD:
			// ebnf.Alternative: Selector | Index | Slice | TypeAssertion | Arguments
			switch p.c().tok {
			case PERIOD: // 0 3
				switch p.c().tok {
				case PERIOD:
					if p.selector() == nil {
						goto _8
					}
				default:
					goto _8
				}
				break
			_8:
				switch p.c().tok {
				case PERIOD:
					if p.typeAssertion() == nil {
						goto _9
					}
				default:
					goto _9
				}
				break
			_9:
				goto _7
			case LBRACK: // 1 2
				switch p.c().tok {
				case LBRACK:
					if p.index() == nil {
						goto _10
					}
				default:
					goto _10
				}
				break
			_10:
				switch p.c().tok {
				case LBRACK:
					if p.slice() == nil {
						goto _11
					}
				default:
					goto _11
				}
				break
			_11:
				goto _7
			case LPAREN: // 4
				switch p.c().tok {
				case LPAREN:
					if p.arguments() == nil {
						goto _7
					}
				default:
					goto _7
				}
			default:
				goto _7
			}
			goto _6
		}
	_7:
	}
	return &PrimaryExprPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// QualifiedIdentNode represents
//
//	QualifiedIdent = PackageName "." identifier .
type QualifiedIdentNode = struct{ noder }

func (p *parser) qualifiedIdent() *QualifiedIdentNode {
	ix := p.ix
	// ebnf.Sequence: PackageName "." identifier
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.packageName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &QualifiedIdentNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RangeClauseNode represents
//
//	RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" ExpressionPreBlock .
type RangeClauseNode = struct{ noder }

func (p *parser) rangeClause() *RangeClauseNode {
	ix := p.ix
	// ebnf.Sequence: [ ExpressionList "=" | IdentifierList ":=" ] "range" ExpressionPreBlock
	{
		ix := p.ix
		// *ebnf.Option: [ ExpressionList "=" | IdentifierList ":=" ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// ebnf.Alternative: ExpressionList "=" | IdentifierList ":="
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR: // 0
				// ebnf.Sequence: ExpressionList "="
				{
					ix := p.ix
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.expressionList() == nil {
							p.back(ix)
							goto _1
						}
					default:
						p.back(ix)
						goto _1
					}
					if p.c().tok == ASSIGN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _1
					}
				}
			case IDENT: // 0 1
				// ebnf.Sequence: ExpressionList "="
				{
					ix := p.ix
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.expressionList() == nil {
							p.back(ix)
							goto _2
						}
					default:
						p.back(ix)
						goto _2
					}
					if p.c().tok == ASSIGN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _2
					}
				}
				break
			_2:
				// ebnf.Sequence: IdentifierList ":="
				{
					ix := p.ix
					switch p.c().tok {
					case IDENT:
						if p.identifierList() == nil {
							p.back(ix)
							goto _3
						}
					default:
						p.back(ix)
						goto _3
					}
					if p.c().tok == DEFINE {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				}
				break
			_3:
				goto _1
			default:
				goto _1
			}
		}
	_1:
		if p.c().tok == RANGE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &RangeClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ReceiverNode represents
//
//	Receiver = Parameters .
type ReceiverNode = struct{ noder }

func (p *parser) receiver() *ReceiverNode {
	ix := p.ix
	switch p.c().tok {
	case LPAREN:
		if p.parameters() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ReceiverNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ReceiverTypeNode represents
//
//	ReceiverType = Type .
type ReceiverTypeNode = struct{ noder }

func (p *parser) receiverType() *ReceiverTypeNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
		if p.type1() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ReceiverTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RecvExprNode represents
//
//	RecvExpr = Expression .
type RecvExprNode = struct{ noder }

func (p *parser) recvExpr() *RecvExprNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &RecvExprNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RecvStmtNode represents
//
//	RecvStmt = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr .
type RecvStmtNode = struct{ noder }

func (p *parser) recvStmt() *RecvStmtNode {
	ix := p.ix
	// ebnf.Sequence: [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr
	{
		ix := p.ix
		// *ebnf.Option: [ ExpressionList "=" | IdentifierList ":=" ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// ebnf.Alternative: ExpressionList "=" | IdentifierList ":="
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR: // 0
				// ebnf.Sequence: ExpressionList "="
				{
					ix := p.ix
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.expressionList() == nil {
							p.back(ix)
							goto _1
						}
					default:
						p.back(ix)
						goto _1
					}
					if p.c().tok == ASSIGN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _1
					}
				}
			case IDENT: // 0 1
				// ebnf.Sequence: ExpressionList "="
				{
					ix := p.ix
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.expressionList() == nil {
							p.back(ix)
							goto _2
						}
					default:
						p.back(ix)
						goto _2
					}
					if p.c().tok == ASSIGN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _2
					}
				}
				break
			_2:
				// ebnf.Sequence: IdentifierList ":="
				{
					ix := p.ix
					switch p.c().tok {
					case IDENT:
						if p.identifierList() == nil {
							p.back(ix)
							goto _3
						}
					default:
						p.back(ix)
						goto _3
					}
					if p.c().tok == DEFINE {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				}
				break
			_3:
				goto _1
			default:
				goto _1
			}
		}
	_1:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.recvExpr() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &RecvStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RelOpNode represents
//
//	RelOp = "==" | "!=" | "<" | "<=" | ">" | ">=" .
type RelOpNode = struct{ noder }

func (p *parser) relOp() *RelOpNode {
	ix := p.ix
	// ebnf.Alternative: "==" | "!=" | "<" | "<=" | ">" | ">="
	switch p.c().tok {
	case EQL: // 0
		if p.c().tok == EQL {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case NEQ: // 1
		if p.c().tok == NEQ {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case LSS: // 2
		if p.c().tok == LSS {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case LEQ: // 3
		if p.c().tok == LEQ {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case GTR: // 4
		if p.c().tok == GTR {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case GEQ: // 5
		if p.c().tok == GEQ {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &RelOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RelationalExpressionNode represents
//
//	RelationalExpression = AdditiveExpression { RelOp AdditiveExpression } .
type RelationalExpressionNode = struct{ noder }

func (p *parser) relationalExpression() *RelationalExpressionNode {
	ix := p.ix
	// ebnf.Sequence: AdditiveExpression { RelOp AdditiveExpression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.additiveExpression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { RelOp AdditiveExpression }
		switch p.c().tok {
		case EQL, GEQ, GTR, LEQ, LSS, NEQ:
			// ebnf.Sequence: RelOp AdditiveExpression
			ix := p.ix
			switch p.c().tok {
			case EQL, GEQ, GTR, LEQ, LSS, NEQ:
				if p.relOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.additiveExpression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &RelationalExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RelationalExpressionPreBlockNode represents
//
//	RelationalExpressionPreBlock = AdditiveExpressionPreBlock { RelOp AdditiveExpressionPreBlock } .
type RelationalExpressionPreBlockNode = struct{ noder }

func (p *parser) relationalExpressionPreBlock() *RelationalExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: AdditiveExpressionPreBlock { RelOp AdditiveExpressionPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.additiveExpressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { RelOp AdditiveExpressionPreBlock }
		switch p.c().tok {
		case EQL, GEQ, GTR, LEQ, LSS, NEQ:
			// ebnf.Sequence: RelOp AdditiveExpressionPreBlock
			ix := p.ix
			switch p.c().tok {
			case EQL, GEQ, GTR, LEQ, LSS, NEQ:
				if p.relOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.additiveExpressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &RelationalExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ResultNode represents
//
//	Result = Parameters | Type .
type ResultNode = struct{ noder }

func (p *parser) result() *ResultNode {
	ix := p.ix
	// ebnf.Alternative: Parameters | Type
	switch p.c().tok {
	case LPAREN: // 0 1
		switch p.c().tok {
		case LPAREN:
			if p.parameters() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		goto _0
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, MAP, MUL, STRUCT: // 1
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &ResultNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ReturnStmtNode represents
//
//	ReturnStmt = "return" [ ExpressionList ] .
type ReturnStmtNode = struct{ noder }

func (p *parser) returnStmt() *ReturnStmtNode {
	ix := p.ix
	// ebnf.Sequence: "return" [ ExpressionList ]
	{
		ix := p.ix
		if p.c().tok == RETURN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ ExpressionList ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionList() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &ReturnStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SelectStmtNode represents
//
//	SelectStmt = "select" "{" { CommClause } "}" .
type SelectStmtNode = struct{ noder }

func (p *parser) selectStmt() *SelectStmtNode {
	ix := p.ix
	// ebnf.Sequence: "select" "{" { CommClause } "}"
	{
		ix := p.ix
		if p.c().tok == SELECT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { CommClause }
		switch p.c().tok {
		case CASE, DEFAULT:
			switch p.c().tok {
			case CASE, DEFAULT:
				if p.commClause() == nil {
					goto _2
				}
			default:
				goto _2
			}
			goto _1
		}
	_2:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &SelectStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SelectorNode represents
//
//	Selector = "." identifier .
type SelectorNode = struct{ noder }

func (p *parser) selector() *SelectorNode {
	ix := p.ix
	// ebnf.Sequence: "." identifier
	{
		ix := p.ix
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &SelectorNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SendStmtNode represents
//
//	SendStmt = Channel "<-" Expression .
type SendStmtNode = struct{ noder }

func (p *parser) sendStmt() *SendStmtNode {
	ix := p.ix
	// ebnf.Sequence: Channel "<-" Expression
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.channel() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == ARROW {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &SendStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SendStmtPreBlockNode represents
//
//	SendStmtPreBlock = Channel "<-" ExpressionPreBlock .
type SendStmtPreBlockNode = struct{ noder }

func (p *parser) sendStmtPreBlock() *SendStmtPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: Channel "<-" ExpressionPreBlock
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.channel() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == ARROW {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &SendStmtPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ShortVarDeclNode represents
//
//	ShortVarDecl = IdentifierList ":=" ExpressionList .
type ShortVarDeclNode = struct{ noder }

func (p *parser) shortVarDecl() *ShortVarDeclNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList ":=" ExpressionList
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == DEFINE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ShortVarDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ShortVarDeclPreBlockNode represents
//
//	ShortVarDeclPreBlock = IdentifierList ":=" ExpressionListPreBlock .
type ShortVarDeclPreBlockNode = struct{ noder }

func (p *parser) shortVarDeclPreBlock() *ShortVarDeclPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList ":=" ExpressionListPreBlock
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == DEFINE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionListPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ShortVarDeclPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SignatureNode represents
//
//	Signature = Parameters [ Result ] .
type SignatureNode = struct{ noder }

func (p *parser) signature() *SignatureNode {
	ix := p.ix
	// ebnf.Sequence: Parameters [ Result ]
	{
		ix := p.ix
		switch p.c().tok {
		case LPAREN:
			if p.parameters() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Result ]
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.result() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &SignatureNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SimpleStmtNode represents
//
//	SimpleStmt = Assignment | ShortVarDecl | IncDecStmt | SendStmt | ExpressionStmt | EmptyStmt .
type SimpleStmtNode = struct{ noder }

func (p *parser) simpleStmt() *SimpleStmtNode {
	ix := p.ix
	// ebnf.Alternative: Assignment | ShortVarDecl | IncDecStmt | SendStmt | ExpressionStmt | EmptyStmt
	switch p.c().tok {
	case IDENT: // 0 1 2 3 4
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.assignment() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case IDENT:
			if p.shortVarDecl() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.incDecStmt() == nil {
				goto _3
			}
		default:
			goto _3
		}
		break
	_3:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.sendStmt() == nil {
				goto _4
			}
		default:
			goto _4
		}
		break
	_4:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionStmt() == nil {
				goto _5
			}
		default:
			goto _5
		}
		break
	_5:
		goto _0
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR: // 0 2 3 4
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.assignment() == nil {
				goto _6
			}
		default:
			goto _6
		}
		break
	_6:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.incDecStmt() == nil {
				goto _7
			}
		default:
			goto _7
		}
		break
	_7:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.sendStmt() == nil {
				goto _8
			}
		default:
			goto _8
		}
		break
	_8:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionStmt() == nil {
				goto _9
			}
		default:
			goto _9
		}
		break
	_9:
		goto _0
	default: //  /* ε */ 5
		if p.emptyStmt() == nil {
			goto _0
		}
	}
	return &SimpleStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SimpleStmtPreBlockNode represents
//
//	SimpleStmtPreBlock = AssignmentPreBlock | ShortVarDeclPreBlock | IncDecStmt | SendStmtPreBlock | ExpressionStmtPreBlock | EmptyStmt .
type SimpleStmtPreBlockNode = struct{ noder }

func (p *parser) simpleStmtPreBlock() *SimpleStmtPreBlockNode {
	ix := p.ix
	// ebnf.Alternative: AssignmentPreBlock | ShortVarDeclPreBlock | IncDecStmt | SendStmtPreBlock | ExpressionStmtPreBlock | EmptyStmt
	switch p.c().tok {
	case IDENT: // 0 1 2 3 4
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.assignmentPreBlock() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case IDENT:
			if p.shortVarDeclPreBlock() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.incDecStmt() == nil {
				goto _3
			}
		default:
			goto _3
		}
		break
	_3:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.sendStmtPreBlock() == nil {
				goto _4
			}
		default:
			goto _4
		}
		break
	_4:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionStmtPreBlock() == nil {
				goto _5
			}
		default:
			goto _5
		}
		break
	_5:
		goto _0
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR: // 0 2 3 4
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.assignmentPreBlock() == nil {
				goto _6
			}
		default:
			goto _6
		}
		break
	_6:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.incDecStmt() == nil {
				goto _7
			}
		default:
			goto _7
		}
		break
	_7:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.sendStmtPreBlock() == nil {
				goto _8
			}
		default:
			goto _8
		}
		break
	_8:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionStmtPreBlock() == nil {
				goto _9
			}
		default:
			goto _9
		}
		break
	_9:
		goto _0
	default: //  /* ε */ 5
		if p.emptyStmt() == nil {
			goto _0
		}
	}
	return &SimpleStmtPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SliceNode represents
//
//	Slice = "[" [ Expression ] ":" [ Expression ] "]" | "[" [ Expression ] ":" Expression ":" Expression "]" .
type SliceNode = struct{ noder }

func (p *parser) slice() *SliceNode {
	ix := p.ix
	// ebnf.Alternative: "[" [ Expression ] ":" [ Expression ] "]" | "[" [ Expression ] ":" Expression ":" Expression "]"
	switch p.c().tok {
	case LBRACK: // 0 1
		// ebnf.Sequence: "[" [ Expression ] ":" [ Expression ] "]"
		{
			ix := p.ix
			if p.c().tok == LBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			// *ebnf.Option: [ Expression ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expression() == nil {
						goto _2
					}
				default:
					goto _2
				}
			}
		_2:
			if p.c().tok == COLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
			// *ebnf.Option: [ Expression ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expression() == nil {
						goto _3
					}
				default:
					goto _3
				}
			}
		_3:
			if p.c().tok == RBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _1
			}
		}
		break
	_1:
		// ebnf.Sequence: "[" [ Expression ] ":" Expression ":" Expression "]"
		{
			ix := p.ix
			if p.c().tok == LBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			// *ebnf.Option: [ Expression ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expression() == nil {
						goto _5
					}
				default:
					goto _5
				}
			}
		_5:
			if p.c().tok == COLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
			if p.c().tok == COLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
			if p.c().tok == RBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
		}
		break
	_4:
		goto _0
	default:
		goto _0
	}
	return &SliceNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SliceTypeNode represents
//
//	SliceType = "[" "]" ElementType .
type SliceTypeNode = struct{ noder }

func (p *parser) sliceType() *SliceTypeNode {
	ix := p.ix
	// ebnf.Sequence: "[" "]" ElementType
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.elementType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &SliceTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SourceFileNode represents
//
//	SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
type SourceFileNode = struct{ noder }

func (p *parser) sourceFile() *SourceFileNode {
	ix := p.ix
	// ebnf.Sequence: PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" }
	{
		ix := p.ix
		switch p.c().tok {
		case PACKAGE:
			if p.packageClause() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == SEMICOLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { ImportDecl ";" }
		switch p.c().tok {
		case IMPORT:
			// ebnf.Sequence: ImportDecl ";"
			ix := p.ix
			switch p.c().tok {
			case IMPORT:
				if p.importDecl() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			if p.c().tok == SEMICOLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	_3:
		// *ebnf.Repetition: { TopLevelDecl ";" }
		switch p.c().tok {
		case CONST, FUNC, TYPE, VAR:
			// ebnf.Sequence: TopLevelDecl ";"
			ix := p.ix
			switch p.c().tok {
			case CONST, FUNC, TYPE, VAR:
				if p.topLevelDecl() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
			if p.c().tok == SEMICOLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			goto _3
		}
	_4:
	}
	return &SourceFileNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// StatementNode represents
//
//	Statement = Declaration | LabeledStmt | GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt | DeferStmt | SimpleStmt .
type StatementNode = struct{ noder }

func (p *parser) statement() *StatementNode {
	ix := p.ix
	// ebnf.Alternative: Declaration | LabeledStmt | GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt | DeferStmt | SimpleStmt
	switch p.c().tok {
	case CONST, TYPE, VAR: // 0
		switch p.c().tok {
		case CONST, TYPE, VAR:
			if p.declaration() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case IDENT: // 1 14
		switch p.c().tok {
		case IDENT:
			if p.labeledStmt() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
			if p.simpleStmt() == nil {
				goto _2
			}
		}
		break
	_2:
		goto _0
	case GO: // 2
		switch p.c().tok {
		case GO:
			if p.goStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case RETURN: // 3
		switch p.c().tok {
		case RETURN:
			if p.returnStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case BREAK: // 4
		switch p.c().tok {
		case BREAK:
			if p.breakStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case CONTINUE: // 5
		switch p.c().tok {
		case CONTINUE:
			if p.continueStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case GOTO: // 6
		switch p.c().tok {
		case GOTO:
			if p.gotoStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case FALLTHROUGH: // 7
		switch p.c().tok {
		case FALLTHROUGH:
			if p.fallthroughStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case LBRACE: // 8
		switch p.c().tok {
		case LBRACE:
			if p.block() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case IF: // 9
		switch p.c().tok {
		case IF:
			if p.ifStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case SWITCH: // 10
		switch p.c().tok {
		case SWITCH:
			if p.switchStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case SELECT: // 11
		switch p.c().tok {
		case SELECT:
			if p.selectStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case FOR: // 12
		switch p.c().tok {
		case FOR:
			if p.forStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case DEFER: // 13
		switch p.c().tok {
		case DEFER:
			if p.deferStmt() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ : // 14
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
			if p.simpleStmt() == nil {
				goto _0
			}
		}
	}
	return &StatementNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// StatementListNode represents
//
//	StatementList = [ Statement { ";" Statement } [ ";" ] ] .
type StatementListNode = struct{ noder }

func (p *parser) statementList() *StatementListNode {
	ix := p.ix
	// *ebnf.Option: [ Statement { ";" Statement } [ ";" ] ]
	switch p.c().tok {
	case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
		// ebnf.Sequence: Statement { ";" Statement } [ ";" ]
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
				if p.statement() == nil {
					p.back(ix)
					goto _1
				}
			}
		_2:
			// *ebnf.Repetition: { ";" Statement }
			switch p.c().tok {
			case SEMICOLON:
				// ebnf.Sequence: ";" Statement
				ix := p.ix
				if p.c().tok == SEMICOLON {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _3
				}
				switch p.c().tok {
				case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
					if p.statement() == nil {
						p.back(ix)
						goto _3
					}
				}
				goto _2
			}
		_3:
			// *ebnf.Option: [ ";" ]
			switch p.c().tok {
			case SEMICOLON:
				if p.c().tok == SEMICOLON {
					p.ix++
					p.budget--
				} else {
					goto _4
				}
			}
		_4:
		}
	}
_1:
	return &StatementListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// StructTypeNode represents
//
//	StructType = "struct" "{" [ FieldDecl { ";" FieldDecl } [ ";" ] ] "}" .
type StructTypeNode = struct{ noder }

func (p *parser) structType() *StructTypeNode {
	ix := p.ix
	// ebnf.Sequence: "struct" "{" [ FieldDecl { ";" FieldDecl } [ ";" ] ] "}"
	{
		ix := p.ix
		if p.c().tok == STRUCT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ FieldDecl { ";" FieldDecl } [ ";" ] ]
		switch p.c().tok {
		case IDENT, MUL:
			// ebnf.Sequence: FieldDecl { ";" FieldDecl } [ ";" ]
			{
				ix := p.ix
				switch p.c().tok {
				case IDENT, MUL:
					if p.fieldDecl() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
			_2:
				// *ebnf.Repetition: { ";" FieldDecl }
				switch p.c().tok {
				case SEMICOLON:
					// ebnf.Sequence: ";" FieldDecl
					ix := p.ix
					if p.c().tok == SEMICOLON {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
					switch p.c().tok {
					case IDENT, MUL:
						if p.fieldDecl() == nil {
							p.back(ix)
							goto _3
						}
					default:
						p.back(ix)
						goto _3
					}
					goto _2
				}
			_3:
				// *ebnf.Option: [ ";" ]
				switch p.c().tok {
				case SEMICOLON:
					if p.c().tok == SEMICOLON {
						p.ix++
						p.budget--
					} else {
						goto _4
					}
				}
			_4:
			}
		}
	_1:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &StructTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SwitchStmtNode represents
//
//	SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
type SwitchStmtNode = struct{ noder }

func (p *parser) switchStmt() *SwitchStmtNode {
	ix := p.ix
	// ebnf.Alternative: ExprSwitchStmt | TypeSwitchStmt
	switch p.c().tok {
	case SWITCH: // 0 1
		switch p.c().tok {
		case SWITCH:
			if p.exprSwitchStmt() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case SWITCH:
			if p.typeSwitchStmt() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		goto _0
	default:
		goto _0
	}
	return &SwitchStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TagNode represents
//
//	Tag = string_lit .
type TagNode = struct{ noder }

func (p *parser) tag() *TagNode {
	ix := p.ix
	if p.c().tok == STRING {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &TagNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TopLevelDeclNode represents
//
//	TopLevelDecl = Declaration | FunctionDecl | MethodDecl .
type TopLevelDeclNode = struct{ noder }

func (p *parser) topLevelDecl() *TopLevelDeclNode {
	ix := p.ix
	// ebnf.Alternative: Declaration | FunctionDecl | MethodDecl
	switch p.c().tok {
	case CONST, TYPE, VAR: // 0
		switch p.c().tok {
		case CONST, TYPE, VAR:
			if p.declaration() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case FUNC: // 1 2
		switch p.c().tok {
		case FUNC:
			if p.functionDecl() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case FUNC:
			if p.methodDecl() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		goto _0
	default:
		goto _0
	}
	return &TopLevelDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeNode represents
//
//	Type = TypeName [ TypeArgs ] | TypeLit | "(" Type ")" .
type TypeNode = struct{ noder }

func (p *parser) type1() *TypeNode {
	ix := p.ix
	// ebnf.Alternative: TypeName [ TypeArgs ] | TypeLit | "(" Type ")"
	switch p.c().tok {
	case IDENT: // 0
		// ebnf.Sequence: TypeName [ TypeArgs ]
		{
			ix := p.ix
			switch p.c().tok {
			case IDENT:
				if p.typeName() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
			// *ebnf.Option: [ TypeArgs ]
			switch p.c().tok {
			case LBRACK:
				switch p.c().tok {
				case LBRACK:
					if p.typeArgs() == nil {
						goto _1
					}
				default:
					goto _1
				}
			}
		_1:
		}
	case ARROW, CHAN, FUNC, INTERFACE, LBRACK, MAP, MUL, STRUCT: // 1
		switch p.c().tok {
		case ARROW, CHAN, FUNC, INTERFACE, LBRACK, MAP, MUL, STRUCT:
			if p.typeLit() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case LPAREN: // 2
		// ebnf.Sequence: "(" Type ")"
		{
			ix := p.ix
			if p.c().tok == LPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
			if p.c().tok == RPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
		}
	default:
		goto _0
	}
	return &TypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeArgsNode represents
//
//	TypeArgs = "[" TypeList [ "," ] "]" .
type TypeArgsNode = struct{ noder }

func (p *parser) typeArgs() *TypeArgsNode {
	ix := p.ix
	// ebnf.Sequence: "[" TypeList [ "," ] "]"
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.typeList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ "," ]
		switch p.c().tok {
		case COMMA:
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				goto _1
			}
		}
	_1:
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeArgsNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeAssertionNode represents
//
//	TypeAssertion = "." "(" Type ")" .
type TypeAssertionNode = struct{ noder }

func (p *parser) typeAssertion() *TypeAssertionNode {
	ix := p.ix
	// ebnf.Sequence: "." "(" Type ")"
	{
		ix := p.ix
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeAssertionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeCaseClauseNode represents
//
//	TypeCaseClause = TypeSwitchCase ":" StatementList .
type TypeCaseClauseNode = struct{ noder }

func (p *parser) typeCaseClause() *TypeCaseClauseNode {
	ix := p.ix
	// ebnf.Sequence: TypeSwitchCase ":" StatementList
	{
		ix := p.ix
		switch p.c().tok {
		case CASE, DEFAULT:
			if p.typeSwitchCase() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == COLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statementList() == nil {
				p.back(ix)
				goto _0
			}
		}
	}
	return &TypeCaseClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeConstraintNode represents
//
//	TypeConstraint = TypeElem .
type TypeConstraintNode = struct{ noder }

func (p *parser) typeConstraint() *TypeConstraintNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
		if p.typeElem() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &TypeConstraintNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeDeclNode represents
//
//	TypeDecl = "type" ( TypeSpec | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")" ) .
type TypeDeclNode = struct{ noder }

func (p *parser) typeDecl() *TypeDeclNode {
	ix := p.ix
	// ebnf.Sequence: "type" ( TypeSpec | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")" )
	{
		ix := p.ix
		if p.c().tok == TYPE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( TypeSpec | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")" )
		switch p.c().tok {
		case IDENT, LPAREN:
			// ebnf.Alternative: TypeSpec | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")"
			switch p.c().tok {
			case IDENT: // 0
				switch p.c().tok {
				case IDENT:
					if p.typeSpec() == nil {
						p.back(ix)
						goto _0
					}
				default:
					p.back(ix)
					goto _0
				}
			case LPAREN: // 1
				// ebnf.Sequence: "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")"
				{
					ix := p.ix
					if p.c().tok == LPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
					// *ebnf.Option: [ TypeSpec { ";" TypeSpec } [ ";" ] ]
					switch p.c().tok {
					case IDENT:
						// ebnf.Sequence: TypeSpec { ";" TypeSpec } [ ";" ]
						{
							ix := p.ix
							switch p.c().tok {
							case IDENT:
								if p.typeSpec() == nil {
									p.back(ix)
									goto _1
								}
							default:
								p.back(ix)
								goto _1
							}
						_2:
							// *ebnf.Repetition: { ";" TypeSpec }
							switch p.c().tok {
							case SEMICOLON:
								// ebnf.Sequence: ";" TypeSpec
								ix := p.ix
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									p.back(ix)
									goto _3
								}
								switch p.c().tok {
								case IDENT:
									if p.typeSpec() == nil {
										p.back(ix)
										goto _3
									}
								default:
									p.back(ix)
									goto _3
								}
								goto _2
							}
						_3:
							// *ebnf.Option: [ ";" ]
							switch p.c().tok {
							case SEMICOLON:
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									goto _4
								}
							}
						_4:
						}
					}
				_1:
					if p.c().tok == RPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
				}
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &TypeDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeDefNode represents
//
//	TypeDef = identifier [ TypeParameters ] Type .
type TypeDefNode = struct{ noder }

func (p *parser) typeDef() *TypeDefNode {
	ix := p.ix
	// ebnf.Sequence: identifier [ TypeParameters ] Type
	{
		ix := p.ix
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ TypeParameters ]
		switch p.c().tok {
		case LBRACK:
			switch p.c().tok {
			case LBRACK:
				if p.typeParameters() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &TypeDefNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeElemNode represents
//
//	TypeElem = TypeTerm { "|" TypeTerm } .
type TypeElemNode = struct{ noder }

func (p *parser) typeElem() *TypeElemNode {
	ix := p.ix
	// ebnf.Sequence: TypeTerm { "|" TypeTerm }
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			if p.typeTerm() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "|" TypeTerm }
		switch p.c().tok {
		case OR:
			// ebnf.Sequence: "|" TypeTerm
			ix := p.ix
			if p.c().tok == OR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
				if p.typeTerm() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &TypeElemNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeListNode represents
//
//	TypeList = Type { "," Type } .
type TypeListNode = struct{ noder }

func (p *parser) typeList() *TypeListNode {
	ix := p.ix
	// ebnf.Sequence: Type { "," Type }
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," Type }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," Type
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &TypeListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeLitNode represents
//
//	TypeLit = ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | ChannelType .
type TypeLitNode = struct{ noder }

func (p *parser) typeLit() *TypeLitNode {
	ix := p.ix
	// ebnf.Alternative: ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | ChannelType
	switch p.c().tok {
	case LBRACK: // 0 5
		switch p.c().tok {
		case LBRACK:
			if p.arrayType() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case LBRACK:
			if p.sliceType() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		goto _0
	case STRUCT: // 1
		switch p.c().tok {
		case STRUCT:
			if p.structType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case MUL: // 2
		switch p.c().tok {
		case MUL:
			if p.pointerType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case FUNC: // 3
		switch p.c().tok {
		case FUNC:
			if p.functionType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case INTERFACE: // 4
		switch p.c().tok {
		case INTERFACE:
			if p.interfaceType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case MAP: // 6
		switch p.c().tok {
		case MAP:
			if p.mapType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case ARROW, CHAN: // 7
		switch p.c().tok {
		case ARROW, CHAN:
			if p.channelType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &TypeLitNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeNameNode represents
//
//	TypeName = QualifiedIdent | identifier .
type TypeNameNode = struct{ noder }

func (p *parser) typeName() *TypeNameNode {
	ix := p.ix
	// ebnf.Alternative: QualifiedIdent | identifier
	switch p.c().tok {
	case IDENT: // 0 1
		switch p.c().tok {
		case IDENT:
			if p.qualifiedIdent() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			goto _2
		}
		break
	_2:
		goto _0
	default:
		goto _0
	}
	return &TypeNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeParamDeclNode represents
//
//	TypeParamDecl = IdentifierList TypeConstraint .
type TypeParamDeclNode = struct{ noder }

func (p *parser) typeParamDecl() *TypeParamDeclNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList TypeConstraint
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			if p.typeConstraint() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &TypeParamDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeParamListNode represents
//
//	TypeParamList = TypeParamDecl { "," TypeParamDecl } .
type TypeParamListNode = struct{ noder }

func (p *parser) typeParamList() *TypeParamListNode {
	ix := p.ix
	// ebnf.Sequence: TypeParamDecl { "," TypeParamDecl }
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.typeParamDecl() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," TypeParamDecl }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," TypeParamDecl
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case IDENT:
				if p.typeParamDecl() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &TypeParamListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeParametersNode represents
//
//	TypeParameters = "[" TypeParamList [ "," ] "]" .
type TypeParametersNode = struct{ noder }

func (p *parser) typeParameters() *TypeParametersNode {
	ix := p.ix
	// ebnf.Sequence: "[" TypeParamList [ "," ] "]"
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.typeParamList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ "," ]
		switch p.c().tok {
		case COMMA:
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				goto _1
			}
		}
	_1:
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeParametersNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeSpecNode represents
//
//	TypeSpec = AliasDecl | TypeDef .
type TypeSpecNode = struct{ noder }

func (p *parser) typeSpec() *TypeSpecNode {
	ix := p.ix
	// ebnf.Alternative: AliasDecl | TypeDef
	switch p.c().tok {
	case IDENT: // 0 1
		switch p.c().tok {
		case IDENT:
			if p.aliasDecl() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		switch p.c().tok {
		case IDENT:
			if p.typeDef() == nil {
				goto _2
			}
		default:
			goto _2
		}
		break
	_2:
		goto _0
	default:
		goto _0
	}
	return &TypeSpecNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeSwitchCaseNode represents
//
//	TypeSwitchCase = "case" TypeList | "default" .
type TypeSwitchCaseNode = struct{ noder }

func (p *parser) typeSwitchCase() *TypeSwitchCaseNode {
	ix := p.ix
	// ebnf.Alternative: "case" TypeList | "default"
	switch p.c().tok {
	case CASE: // 0
		// ebnf.Sequence: "case" TypeList
		{
			ix := p.ix
			if p.c().tok == CASE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.typeList() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		}
	case DEFAULT: // 1
		if p.c().tok == DEFAULT {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &TypeSwitchCaseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeSwitchGuardNode represents
//
//	TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
type TypeSwitchGuardNode = struct{ noder }

func (p *parser) typeSwitchGuard() *TypeSwitchGuardNode {
	ix := p.ix
	// ebnf.Sequence: [ identifier ":=" ] PrimaryExpr "." "(" "type" ")"
	{
		ix := p.ix
		// *ebnf.Option: [ identifier ":=" ]
		switch p.c().tok {
		case IDENT:
			// ebnf.Sequence: identifier ":="
			{
				ix := p.ix
				if p.c().tok == IDENT {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
				if p.c().tok == DEFINE {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
			}
		}
	_1:
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.primaryExpr() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == TYPE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeSwitchGuardNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeSwitchStmtNode represents
//
//	TypeSwitchStmt = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
type TypeSwitchStmtNode = struct{ noder }

func (p *parser) typeSwitchStmt() *TypeSwitchStmtNode {
	ix := p.ix
	// ebnf.Sequence: "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}"
	{
		ix := p.ix
		if p.c().tok == SWITCH {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ SimpleStmt ";" ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, SEMICOLON, STRING, STRUCT, SUB, XOR:
			// ebnf.Sequence: SimpleStmt ";"
			{
				ix := p.ix
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
					if p.simpleStmt() == nil {
						p.back(ix)
						goto _1
					}
				}
				if p.c().tok == SEMICOLON {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
			}
		}
	_1:
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.typeSwitchGuard() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	_2:
		// *ebnf.Repetition: { TypeCaseClause }
		switch p.c().tok {
		case CASE, DEFAULT:
			switch p.c().tok {
			case CASE, DEFAULT:
				if p.typeCaseClause() == nil {
					goto _3
				}
			default:
				goto _3
			}
			goto _2
		}
	_3:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeSwitchStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeTermNode represents
//
//	TypeTerm = Type | UnderlyingType .
type TypeTermNode = struct{ noder }

func (p *parser) typeTerm() *TypeTermNode {
	ix := p.ix
	// ebnf.Alternative: Type | UnderlyingType
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT: // 0
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case TILDE: // 1
		switch p.c().tok {
		case TILDE:
			if p.underlyingType() == nil {
				goto _0
			}
		default:
			goto _0
		}
	default:
		goto _0
	}
	return &TypeTermNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// UnaryExprNode represents
//
//	UnaryExpr = PrimaryExpr | UnaryOp UnaryExpr .
type UnaryExprNode = struct{ noder }

func (p *parser) unaryExpr() *UnaryExprNode {
	ix := p.ix
	// ebnf.Alternative: PrimaryExpr | UnaryOp UnaryExpr
	switch p.c().tok {
	case CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, STRING, STRUCT: // 0
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.primaryExpr() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case ARROW, MUL: // 0 1
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.primaryExpr() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		// ebnf.Sequence: UnaryOp UnaryExpr
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, MUL, NOT, SUB, XOR:
				if p.unaryOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExpr() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		break
	_2:
		goto _0
	case ADD, AND, NOT, SUB, XOR: // 1
		// ebnf.Sequence: UnaryOp UnaryExpr
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, MUL, NOT, SUB, XOR:
				if p.unaryOp() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExpr() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		}
	default:
		goto _0
	}
	return &UnaryExprNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// UnaryExprPreBlockPreBlockNode represents
//
//	UnaryExprPreBlockPreBlock = PrimaryExprPreBlock | UnaryOp UnaryExprPreBlockPreBlock .
type UnaryExprPreBlockPreBlockNode = struct{ noder }

func (p *parser) unaryExprPreBlockPreBlock() *UnaryExprPreBlockPreBlockNode {
	ix := p.ix
	// ebnf.Alternative: PrimaryExprPreBlock | UnaryOp UnaryExprPreBlockPreBlock
	switch p.c().tok {
	case CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, STRING, STRUCT: // 0
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.primaryExprPreBlock() == nil {
				goto _0
			}
		default:
			goto _0
		}
	case ARROW, MUL: // 0 1
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.primaryExprPreBlock() == nil {
				goto _1
			}
		default:
			goto _1
		}
		break
	_1:
		// ebnf.Sequence: UnaryOp UnaryExprPreBlockPreBlock
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, MUL, NOT, SUB, XOR:
				if p.unaryOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExprPreBlockPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		break
	_2:
		goto _0
	case ADD, AND, NOT, SUB, XOR: // 1
		// ebnf.Sequence: UnaryOp UnaryExprPreBlockPreBlock
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, MUL, NOT, SUB, XOR:
				if p.unaryOp() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExprPreBlockPreBlock() == nil {
					p.back(ix)
					goto _0
				}
			default:
				p.back(ix)
				goto _0
			}
		}
	default:
		goto _0
	}
	return &UnaryExprPreBlockPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// UnaryOpNode represents
//
//	UnaryOp = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
type UnaryOpNode = struct{ noder }

func (p *parser) unaryOp() *UnaryOpNode {
	ix := p.ix
	// ebnf.Alternative: "+" | "-" | "!" | "^" | "*" | "&" | "<-"
	switch p.c().tok {
	case ADD: // 0
		if p.c().tok == ADD {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case SUB: // 1
		if p.c().tok == SUB {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case NOT: // 2
		if p.c().tok == NOT {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case XOR: // 3
		if p.c().tok == XOR {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case MUL: // 4
		if p.c().tok == MUL {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case AND: // 5
		if p.c().tok == AND {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	case ARROW: // 6
		if p.c().tok == ARROW {
			p.ix++
			p.budget--
		} else {
			goto _0
		}
	default:
		goto _0
	}
	return &UnaryOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// UnderlyingTypeNode represents
//
//	UnderlyingType = "~" Type .
type UnderlyingTypeNode = struct{ noder }

func (p *parser) underlyingType() *UnderlyingTypeNode {
	ix := p.ix
	// ebnf.Sequence: "~" Type
	{
		ix := p.ix
		if p.c().tok == TILDE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &UnderlyingTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// VarDeclNode represents
//
//	VarDecl = "var" ( VarSpec | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")" ) .
type VarDeclNode = struct{ noder }

func (p *parser) varDecl() *VarDeclNode {
	ix := p.ix
	// ebnf.Sequence: "var" ( VarSpec | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")" )
	{
		ix := p.ix
		if p.c().tok == VAR {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( VarSpec | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")" )
		switch p.c().tok {
		case IDENT, LPAREN:
			// ebnf.Alternative: VarSpec | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")"
			switch p.c().tok {
			case IDENT: // 0
				switch p.c().tok {
				case IDENT:
					if p.varSpec() == nil {
						p.back(ix)
						goto _0
					}
				default:
					p.back(ix)
					goto _0
				}
			case LPAREN: // 1
				// ebnf.Sequence: "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")"
				{
					ix := p.ix
					if p.c().tok == LPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
					// *ebnf.Option: [ VarSpec { ";" VarSpec } [ ";" ] ]
					switch p.c().tok {
					case IDENT:
						// ebnf.Sequence: VarSpec { ";" VarSpec } [ ";" ]
						{
							ix := p.ix
							switch p.c().tok {
							case IDENT:
								if p.varSpec() == nil {
									p.back(ix)
									goto _1
								}
							default:
								p.back(ix)
								goto _1
							}
						_2:
							// *ebnf.Repetition: { ";" VarSpec }
							switch p.c().tok {
							case SEMICOLON:
								// ebnf.Sequence: ";" VarSpec
								ix := p.ix
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									p.back(ix)
									goto _3
								}
								switch p.c().tok {
								case IDENT:
									if p.varSpec() == nil {
										p.back(ix)
										goto _3
									}
								default:
									p.back(ix)
									goto _3
								}
								goto _2
							}
						_3:
							// *ebnf.Option: [ ";" ]
							switch p.c().tok {
							case SEMICOLON:
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									goto _4
								}
							}
						_4:
						}
					}
				_1:
					if p.c().tok == RPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
				}
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &VarDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// VarSpecNode represents
//
//	VarSpec = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
type VarSpecNode = struct{ noder }

func (p *parser) varSpec() *VarSpecNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList )
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( Type [ "=" ExpressionList ] | "=" ExpressionList )
		switch p.c().tok {
		case ARROW, ASSIGN, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			// ebnf.Alternative: Type [ "=" ExpressionList ] | "=" ExpressionList
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT: // 0
				// ebnf.Sequence: Type [ "=" ExpressionList ]
				{
					ix := p.ix
					switch p.c().tok {
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
						if p.type1() == nil {
							p.back(ix)
							p.back(ix)
							goto _0
						}
					default:
						p.back(ix)
						p.back(ix)
						goto _0
					}
					// *ebnf.Option: [ "=" ExpressionList ]
					switch p.c().tok {
					case ASSIGN:
						// ebnf.Sequence: "=" ExpressionList
						{
							ix := p.ix
							if p.c().tok == ASSIGN {
								p.ix++
								p.budget--
							} else {
								p.back(ix)
								goto _1
							}
							switch p.c().tok {
							case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
								if p.expressionList() == nil {
									p.back(ix)
									goto _1
								}
							default:
								p.back(ix)
								goto _1
							}
						}
					}
				_1:
				}
			case ASSIGN: // 1
				// ebnf.Sequence: "=" ExpressionList
				{
					ix := p.ix
					if p.c().tok == ASSIGN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						p.back(ix)
						goto _0
					}
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.expressionList() == nil {
							p.back(ix)
							p.back(ix)
							goto _0
						}
					default:
						p.back(ix)
						p.back(ix)
						goto _0
					}
				}
			default:
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &VarSpecNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}
