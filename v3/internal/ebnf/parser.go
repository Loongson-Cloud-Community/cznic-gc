// Code generated by '$ go test -gen -run TestGen' DO NOT EDIT.

package main

// AddOpNode represents

//	AddOp = "+" | "-" | "|" | "^" .
type AddOpNode = struct{}

func (p *parser) addOp() *AddOpNode {
	ix := p.ix
	// true: ADD
	// true: SUB
	// true: OR
	// true: XOR
	// single: ADD, OR, SUB, XOR
	// multi:
	// ebnf.Alternative: "+" | "-" | "|" | "^"
	{
		if p.c().tok == ADD {
			p.ix++
			p.budget--
		} else {
			goto _2
		}
		goto _1
	_2:
		if p.c().tok == SUB {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		if p.c().tok == OR {
			p.ix++
			p.budget--
		} else {
			goto _4
		}
		goto _1
	_4:
		if p.c().tok == XOR {
			p.ix++
			p.budget--
		} else {
			goto _5
		}
		goto _1
	_5:
		goto _0
	}
_1:
	return &AddOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AdditiveExpressionNode represents

//	AdditiveExpression = MultiplicativeExpression { AddOp MultiplicativeExpression } .
type AdditiveExpressionNode = struct{}

func (p *parser) additiveExpression() *AdditiveExpressionNode {
	ix := p.ix
	// ebnf.Sequence: MultiplicativeExpression { AddOp MultiplicativeExpression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.multiplicativeExpression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { AddOp MultiplicativeExpression }
		switch p.c().tok {
		case ADD, OR, SUB, XOR:
			// ebnf.Sequence: AddOp MultiplicativeExpression
			ix := p.ix
			switch p.c().tok {
			case ADD, OR, SUB, XOR:
				if p.addOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.multiplicativeExpression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &AdditiveExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AdditiveExpressionPreBlockNode represents

//	AdditiveExpressionPreBlock = MultiplicativeExpressionPreBlock { AddOp MultiplicativeExpressionPreBlock } .
type AdditiveExpressionPreBlockNode = struct{}

func (p *parser) additiveExpressionPreBlock() *AdditiveExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: MultiplicativeExpressionPreBlock { AddOp MultiplicativeExpressionPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.multiplicativeExpressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { AddOp MultiplicativeExpressionPreBlock }
		switch p.c().tok {
		case ADD, OR, SUB, XOR:
			// ebnf.Sequence: AddOp MultiplicativeExpressionPreBlock
			ix := p.ix
			switch p.c().tok {
			case ADD, OR, SUB, XOR:
				if p.addOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.multiplicativeExpressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &AdditiveExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AliasDeclNode represents

//	AliasDecl = identifier "=" Type .
type AliasDeclNode = struct{}

func (p *parser) aliasDecl() *AliasDeclNode {
	ix := p.ix
	// ebnf.Sequence: identifier "=" Type
	{
		ix := p.ix
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == ASSIGN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &AliasDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ArgumentsNode represents

//	Arguments = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
type ArgumentsNode = struct{}

func (p *parser) arguments() *ArgumentsNode {
	ix := p.ix
	// ebnf.Sequence: "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")"
	{
		ix := p.ix
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// ebnf.Sequence: ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ]
			{
				ix := p.ix
				// *ebnf.Group: ( ExpressionList | Type [ "," ExpressionList ] )
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
					// false: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
					// single: ADD, AND, CHAR, FLOAT, IMAG, INT, NOT, STRING, SUB, XOR
					// multi: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
					// ebnf.Alternative: ExpressionList | Type [ "," ExpressionList ]
					{
						switch p.c().tok {
						case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
							if p.expressionList() == nil {
								goto _3
							}
						default:
							goto _3
						}
						goto _2
					_3:
						// ebnf.Sequence: Type [ "," ExpressionList ]
						{
							ix := p.ix
							switch p.c().tok {
							case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
								if p.type1() == nil {
									p.back(ix)
									goto _4
								}
							default:
								p.back(ix)
								goto _4
							}
							// *ebnf.Option: [ "," ExpressionList ]
							switch p.c().tok {
							case COMMA:
								// ebnf.Sequence: "," ExpressionList
								{
									ix := p.ix
									if p.c().tok == COMMA {
										p.ix++
										p.budget--
									} else {
										p.back(ix)
										goto _5
									}
									switch p.c().tok {
									case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
										if p.expressionList() == nil {
											p.back(ix)
											goto _5
										}
									default:
										p.back(ix)
										goto _5
									}
								}
							}
						_5:
						}
						goto _2
					_4:
						p.back(ix)
						goto _1
					}
				_2:
					;
				default:
					p.back(ix)
					goto _1
				}
				// *ebnf.Option: [ "..." ]
				switch p.c().tok {
				case ELLIPSIS:
					if p.c().tok == ELLIPSIS {
						p.ix++
						p.budget--
					} else {
						goto _6
					}
				}
			_6:
				// *ebnf.Option: [ "," ]
				switch p.c().tok {
				case COMMA:
					if p.c().tok == COMMA {
						p.ix++
						p.budget--
					} else {
						goto _7
					}
				}
			_7:
			}
		}
	_1:
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &ArgumentsNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ArrayLengthNode represents

//	ArrayLength = Expression .
type ArrayLengthNode = struct{}

func (p *parser) arrayLength() *ArrayLengthNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ArrayLengthNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ArrayTypeNode represents

//	ArrayType = "[" ArrayLength "]" ElementType .
type ArrayTypeNode = struct{}

func (p *parser) arrayType() *ArrayTypeNode {
	ix := p.ix
	// ebnf.Sequence: "[" ArrayLength "]" ElementType
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.arrayLength() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.elementType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ArrayTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AssignOpNode represents

//	AssignOp = "=" | "+=" | "-=" | "|=" | "^=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "&^=" .
type AssignOpNode = struct{}

func (p *parser) assignOp() *AssignOpNode {
	ix := p.ix
	// true: ASSIGN
	// true: ADD_ASSIGN
	// true: SUB_ASSIGN
	// true: OR_ASSIGN
	// true: XOR_ASSIGN
	// true: MUL_ASSIGN
	// true: QUO_ASSIGN
	// true: REM_ASSIGN
	// true: SHL_ASSIGN
	// true: SHR_ASSIGN
	// true: AND_ASSIGN
	// true: AND_NOT_ASSIGN
	// single: ADD_ASSIGN, AND_ASSIGN, AND_NOT_ASSIGN, ASSIGN, MUL_ASSIGN, OR_ASSIGN, QUO_ASSIGN, REM_ASSIGN, SHL_ASSIGN, SHR_ASSIGN, SUB_ASSIGN, XOR_ASSIGN
	// multi:
	// ebnf.Alternative: "=" | "+=" | "-=" | "|=" | "^=" | "*=" | "/=" | "%=" | "<<=" | ">>=" | "&=" | "&^="
	{
		if p.c().tok == ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _2
		}
		goto _1
	_2:
		if p.c().tok == ADD_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		if p.c().tok == SUB_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _4
		}
		goto _1
	_4:
		if p.c().tok == OR_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _5
		}
		goto _1
	_5:
		if p.c().tok == XOR_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _6
		}
		goto _1
	_6:
		if p.c().tok == MUL_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _7
		}
		goto _1
	_7:
		if p.c().tok == QUO_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _8
		}
		goto _1
	_8:
		if p.c().tok == REM_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _9
		}
		goto _1
	_9:
		if p.c().tok == SHL_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _10
		}
		goto _1
	_10:
		if p.c().tok == SHR_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _11
		}
		goto _1
	_11:
		if p.c().tok == AND_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _12
		}
		goto _1
	_12:
		if p.c().tok == AND_NOT_ASSIGN {
			p.ix++
			p.budget--
		} else {
			goto _13
		}
		goto _1
	_13:
		goto _0
	}
_1:
	return &AssignOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AssignmentNode represents

//	Assignment = ExpressionList AssignOp ExpressionList .
type AssignmentNode = struct{}

func (p *parser) assignment() *AssignmentNode {
	ix := p.ix
	// ebnf.Sequence: ExpressionList AssignOp ExpressionList
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD_ASSIGN, AND_ASSIGN, AND_NOT_ASSIGN, ASSIGN, MUL_ASSIGN, OR_ASSIGN, QUO_ASSIGN, REM_ASSIGN, SHL_ASSIGN, SHR_ASSIGN, SUB_ASSIGN, XOR_ASSIGN:
			if p.assignOp() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &AssignmentNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// AssignmentPreBlockNode represents

//	AssignmentPreBlock = ExpressionList AssignOp ExpressionListPreBlock .
type AssignmentPreBlockNode = struct{}

func (p *parser) assignmentPreBlock() *AssignmentPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: ExpressionList AssignOp ExpressionListPreBlock
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD_ASSIGN, AND_ASSIGN, AND_NOT_ASSIGN, ASSIGN, MUL_ASSIGN, OR_ASSIGN, QUO_ASSIGN, REM_ASSIGN, SHL_ASSIGN, SHR_ASSIGN, SUB_ASSIGN, XOR_ASSIGN:
			if p.assignOp() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionListPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &AssignmentPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// BaseTypeNode represents

//	BaseType = Type .
type BaseTypeNode = struct{}

func (p *parser) baseType() *BaseTypeNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
		if p.type1() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &BaseTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// BasicLitNode represents

//	BasicLit = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
type BasicLitNode = struct{}

func (p *parser) basicLit() *BasicLitNode {
	ix := p.ix
	// true: INT
	// true: FLOAT
	// true: IMAG
	// true: CHAR
	// true: STRING
	// single: CHAR, FLOAT, IMAG, INT, STRING
	// multi:
	// ebnf.Alternative: int_lit | float_lit | imaginary_lit | rune_lit | string_lit
	{
		if p.c().tok == INT {
			p.ix++
			p.budget--
		} else {
			goto _2
		}
		goto _1
	_2:
		if p.c().tok == FLOAT {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		if p.c().tok == IMAG {
			p.ix++
			p.budget--
		} else {
			goto _4
		}
		goto _1
	_4:
		if p.c().tok == CHAR {
			p.ix++
			p.budget--
		} else {
			goto _5
		}
		goto _1
	_5:
		if p.c().tok == STRING {
			p.ix++
			p.budget--
		} else {
			goto _6
		}
		goto _1
	_6:
		goto _0
	}
_1:
	return &BasicLitNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// BlockNode represents

//	Block = "{" StatementList "}" .
type BlockNode = struct{}

func (p *parser) block() *BlockNode {
	ix := p.ix
	// ebnf.Sequence: "{" StatementList "}"
	{
		ix := p.ix
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statementList() == nil {
				p.back(ix)
				goto _0
			}
		}
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &BlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// BreakStmtNode represents

//	BreakStmt = "break" [ Label ] .
type BreakStmtNode = struct{}

func (p *parser) breakStmt() *BreakStmtNode {
	ix := p.ix
	// ebnf.Sequence: "break" [ Label ]
	{
		ix := p.ix
		if p.c().tok == BREAK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Label ]
		switch p.c().tok {
		case IDENT:
			switch p.c().tok {
			case IDENT:
				if p.label() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &BreakStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ChannelNode represents

//	Channel = Expression .
type ChannelNode = struct{}

func (p *parser) channel() *ChannelNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ChannelNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ChannelTypeNode represents

//	ChannelType = "<-" "chan" ElementType | "chan" "<-" ElementType | "chan" ElementType .
type ChannelTypeNode = struct{}

func (p *parser) channelType() *ChannelTypeNode {
	ix := p.ix
	// true: ARROW
	// false: CHAN
	// false: CHAN
	// single: ARROW
	// multi: CHAN
	// ebnf.Alternative: "<-" "chan" ElementType | "chan" "<-" ElementType | "chan" ElementType
	{
		// ebnf.Sequence: "<-" "chan" ElementType
		{
			ix := p.ix
			if p.c().tok == ARROW {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			if p.c().tok == CHAN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		goto _1
	_2:
		// ebnf.Sequence: "chan" "<-" ElementType
		{
			ix := p.ix
			if p.c().tok == CHAN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _3
			}
			if p.c().tok == ARROW {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
		}
		goto _1
	_3:
		// ebnf.Sequence: "chan" ElementType
		{
			ix := p.ix
			if p.c().tok == CHAN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
		}
		goto _1
	_4:
		goto _0
	}
_1:
	return &ChannelTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// CommCaseNode represents

//	CommCase = "case" ( SendStmt | RecvStmt ) | "default" .
type CommCaseNode = struct{}

func (p *parser) commCase() *CommCaseNode {
	ix := p.ix
	// true: CASE
	// true: DEFAULT
	// single: CASE, DEFAULT
	// multi:
	// ebnf.Alternative: "case" ( SendStmt | RecvStmt ) | "default"
	{
		// ebnf.Sequence: "case" ( SendStmt | RecvStmt )
		{
			ix := p.ix
			if p.c().tok == CASE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			// *ebnf.Group: ( SendStmt | RecvStmt )
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
				// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
				// single:
				// multi: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
				// ebnf.Alternative: SendStmt | RecvStmt
				{
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.sendStmt() == nil {
							goto _4
						}
					default:
						goto _4
					}
					goto _3
				_4:
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.recvStmt() == nil {
							goto _5
						}
					default:
						goto _5
					}
					goto _3
				_5:
					p.back(ix)
					goto _2
				}
			_3:
				;
			default:
				p.back(ix)
				goto _2
			}
		}
		goto _1
	_2:
		if p.c().tok == DEFAULT {
			p.ix++
			p.budget--
		} else {
			goto _6
		}
		goto _1
	_6:
		goto _0
	}
_1:
	return &CommCaseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// CommClauseNode represents

//	CommClause = CommCase ":" StatementList .
type CommClauseNode = struct{}

func (p *parser) commClause() *CommClauseNode {
	ix := p.ix
	// ebnf.Sequence: CommCase ":" StatementList
	{
		ix := p.ix
		switch p.c().tok {
		case CASE, DEFAULT:
			if p.commCase() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == COLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statementList() == nil {
				p.back(ix)
				goto _0
			}
		}
	}
	return &CommClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// CompositeLitNode represents

//	CompositeLit = LiteralType LiteralValue .
type CompositeLitNode = struct{}

func (p *parser) compositeLit() *CompositeLitNode {
	ix := p.ix
	// ebnf.Sequence: LiteralType LiteralValue
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT, LBRACK, MAP, STRUCT:
			if p.literalType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LBRACE:
			if p.literalValue() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &CompositeLitNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// CompositeLitPreBlockNode represents

//	CompositeLitPreBlock = LiteralTypePreBlock LiteralValue .
type CompositeLitPreBlockNode = struct{}

func (p *parser) compositeLitPreBlock() *CompositeLitPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: LiteralTypePreBlock LiteralValue
	{
		ix := p.ix
		switch p.c().tok {
		case LBRACK, MAP, STRUCT:
			if p.literalTypePreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LBRACE:
			if p.literalValue() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &CompositeLitPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ConditionNode represents

//	Condition = Expression .
type ConditionNode = struct{}

func (p *parser) condition() *ConditionNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ConditionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ConstDeclNode represents

//	ConstDecl = "const" ( ConstSpec | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")" ) .
type ConstDeclNode = struct{}

func (p *parser) constDecl() *ConstDeclNode {
	ix := p.ix
	// ebnf.Sequence: "const" ( ConstSpec | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")" )
	{
		ix := p.ix
		if p.c().tok == CONST {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( ConstSpec | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")" )
		switch p.c().tok {
		case IDENT, LPAREN:
			// true: IDENT
			// true: LPAREN
			// single: IDENT, LPAREN
			// multi:
			// ebnf.Alternative: ConstSpec | "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")"
			{
				switch p.c().tok {
				case IDENT:
					if p.constSpec() == nil {
						goto _2
					}
				default:
					goto _2
				}
				goto _1
			_2:
				// ebnf.Sequence: "(" [ ConstSpec { ";" ConstSpec } [ ";" ] ] ")"
				{
					ix := p.ix
					if p.c().tok == LPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
					// *ebnf.Option: [ ConstSpec { ";" ConstSpec } [ ";" ] ]
					switch p.c().tok {
					case IDENT:
						// ebnf.Sequence: ConstSpec { ";" ConstSpec } [ ";" ]
						{
							ix := p.ix
							switch p.c().tok {
							case IDENT:
								if p.constSpec() == nil {
									p.back(ix)
									goto _4
								}
							default:
								p.back(ix)
								goto _4
							}
						_5:
							// *ebnf.Repetition: { ";" ConstSpec }
							switch p.c().tok {
							case SEMICOLON:
								// ebnf.Sequence: ";" ConstSpec
								ix := p.ix
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									p.back(ix)
									goto _6
								}
								switch p.c().tok {
								case IDENT:
									if p.constSpec() == nil {
										p.back(ix)
										goto _6
									}
								default:
									p.back(ix)
									goto _6
								}
								goto _5
							}
						_6:
							// *ebnf.Option: [ ";" ]
							switch p.c().tok {
							case SEMICOLON:
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									goto _7
								}
							}
						_7:
						}
					}
				_4:
					if p.c().tok == RPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				}
				goto _1
			_3:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ConstDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ConstSpecNode represents

//	ConstSpec = IdentifierList [ [ Type ] "=" ExpressionList ] .
type ConstSpecNode = struct{}

func (p *parser) constSpec() *ConstSpecNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList [ [ Type ] "=" ExpressionList ]
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ [ Type ] "=" ExpressionList ]
		switch p.c().tok {
		case ARROW, ASSIGN, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			// ebnf.Sequence: [ Type ] "=" ExpressionList
			{
				ix := p.ix
				// *ebnf.Option: [ Type ]
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					switch p.c().tok {
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
						if p.type1() == nil {
							goto _2
						}
					default:
						goto _2
					}
				}
			_2:
				if p.c().tok == ASSIGN {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expressionList() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
			}
		}
	_1:
	}
	return &ConstSpecNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ContinueStmtNode represents

//	ContinueStmt = "continue" [ Label ] .
type ContinueStmtNode = struct{}

func (p *parser) continueStmt() *ContinueStmtNode {
	ix := p.ix
	// ebnf.Sequence: "continue" [ Label ]
	{
		ix := p.ix
		if p.c().tok == CONTINUE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Label ]
		switch p.c().tok {
		case IDENT:
			switch p.c().tok {
			case IDENT:
				if p.label() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &ContinueStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ConversionNode represents

//	Conversion = Type "(" Expression [ "," ] ")" .
type ConversionNode = struct{}

func (p *parser) conversion() *ConversionNode {
	ix := p.ix
	// ebnf.Sequence: Type "(" Expression [ "," ] ")"
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ "," ]
		switch p.c().tok {
		case COMMA:
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				goto _1
			}
		}
	_1:
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &ConversionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// DeclarationNode represents

//	Declaration = ConstDecl | TypeDecl | VarDecl .
type DeclarationNode = struct{}

func (p *parser) declaration() *DeclarationNode {
	ix := p.ix
	// true: CONST
	// true: TYPE
	// true: VAR
	// single: CONST, TYPE, VAR
	// multi:
	// ebnf.Alternative: ConstDecl | TypeDecl | VarDecl
	{
		switch p.c().tok {
		case CONST:
			if p.constDecl() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case TYPE:
			if p.typeDecl() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case VAR:
			if p.varDecl() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		goto _0
	}
_1:
	return &DeclarationNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// DeferStmtNode represents

//	DeferStmt = "defer" Expression .
type DeferStmtNode = struct{}

func (p *parser) deferStmt() *DeferStmtNode {
	ix := p.ix
	// ebnf.Sequence: "defer" Expression
	{
		ix := p.ix
		if p.c().tok == DEFER {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &DeferStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ElementNode represents

//	Element = Expression | LiteralValue .
type ElementNode = struct{}

func (p *parser) element() *ElementNode {
	ix := p.ix
	// true: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// true: LBRACE
	// single: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// multi:
	// ebnf.Alternative: Expression | LiteralValue
	{
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case LBRACE:
			if p.literalValue() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &ElementNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ElementListNode represents

//	ElementList = KeyedElement { "," KeyedElement } .
type ElementListNode = struct{}

func (p *parser) elementList() *ElementListNode {
	ix := p.ix
	// ebnf.Sequence: KeyedElement { "," KeyedElement }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.keyedElement() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," KeyedElement }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," KeyedElement
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.keyedElement() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ElementListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ElementTypeNode represents

//	ElementType = Type .
type ElementTypeNode = struct{}

func (p *parser) elementType() *ElementTypeNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
		if p.type1() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ElementTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// EmbeddedFieldNode represents

//	EmbeddedField = [ "*" ] TypeName [ TypeArgs ] .
type EmbeddedFieldNode = struct{}

func (p *parser) embeddedField() *EmbeddedFieldNode {
	ix := p.ix
	// ebnf.Sequence: [ "*" ] TypeName [ TypeArgs ]
	{
		ix := p.ix
		// *ebnf.Option: [ "*" ]
		switch p.c().tok {
		case MUL:
			if p.c().tok == MUL {
				p.ix++
				p.budget--
			} else {
				goto _1
			}
		}
	_1:
		switch p.c().tok {
		case IDENT:
			if p.typeName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ TypeArgs ]
		switch p.c().tok {
		case LBRACK:
			switch p.c().tok {
			case LBRACK:
				if p.typeArgs() == nil {
					goto _2
				}
			default:
				goto _2
			}
		}
	_2:
	}
	return &EmbeddedFieldNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// EmptyStmtNode represents

//	EmptyStmt =  .
type EmptyStmtNode = struct{}

func (p *parser) emptyStmt() *EmptyStmtNode {
	return &EmptyStmtNode{}
}

// ExprCaseClauseNode represents

//	ExprCaseClause = ExprSwitchCase ":" StatementList .
type ExprCaseClauseNode = struct{}

func (p *parser) exprCaseClause() *ExprCaseClauseNode {
	ix := p.ix
	// ebnf.Sequence: ExprSwitchCase ":" StatementList
	{
		ix := p.ix
		switch p.c().tok {
		case CASE, DEFAULT:
			if p.exprSwitchCase() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == COLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statementList() == nil {
				p.back(ix)
				goto _0
			}
		}
	}
	return &ExprCaseClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExprSwitchCaseNode represents

//	ExprSwitchCase = "case" ExpressionList | "default" .
type ExprSwitchCaseNode = struct{}

func (p *parser) exprSwitchCase() *ExprSwitchCaseNode {
	ix := p.ix
	// true: CASE
	// true: DEFAULT
	// single: CASE, DEFAULT
	// multi:
	// ebnf.Alternative: "case" ExpressionList | "default"
	{
		// ebnf.Sequence: "case" ExpressionList
		{
			ix := p.ix
			if p.c().tok == CASE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionList() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		goto _1
	_2:
		if p.c().tok == DEFAULT {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &ExprSwitchCaseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExprSwitchStmtNode represents

//	ExprSwitchStmt = "switch" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}" | "switch" SimpleStmt ";" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}" .
type ExprSwitchStmtNode = struct{}

func (p *parser) exprSwitchStmt() *ExprSwitchStmtNode {
	ix := p.ix
	// false: SWITCH
	// false: SWITCH
	// single:
	// multi: SWITCH
	// ebnf.Alternative: "switch" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}" | "switch" SimpleStmt ";" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}"
	{
		// ebnf.Sequence: "switch" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}"
		{
			ix := p.ix
			if p.c().tok == SWITCH {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			// *ebnf.Option: [ ExpressionPreBlock ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expressionPreBlock() == nil {
						goto _3
					}
				default:
					goto _3
				}
			}
		_3:
			if p.c().tok == LBRACE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
		_4:
			// *ebnf.Repetition: { ExprCaseClause }
			switch p.c().tok {
			case CASE, DEFAULT:
				switch p.c().tok {
				case CASE, DEFAULT:
					if p.exprCaseClause() == nil {
						goto _5
					}
				default:
					goto _5
				}
				goto _4
			}
		_5:
			if p.c().tok == RBRACE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
		}
		goto _1
	_2:
		// ebnf.Sequence: "switch" SimpleStmt ";" [ ExpressionPreBlock ] "{" { ExprCaseClause } "}"
		{
			ix := p.ix
			if p.c().tok == SWITCH {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _6
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
				if p.simpleStmt() == nil {
					p.back(ix)
					goto _6
				}
			}
			if p.c().tok == SEMICOLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _6
			}
			// *ebnf.Option: [ ExpressionPreBlock ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expressionPreBlock() == nil {
						goto _7
					}
				default:
					goto _7
				}
			}
		_7:
			if p.c().tok == LBRACE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _6
			}
		_8:
			// *ebnf.Repetition: { ExprCaseClause }
			switch p.c().tok {
			case CASE, DEFAULT:
				switch p.c().tok {
				case CASE, DEFAULT:
					if p.exprCaseClause() == nil {
						goto _9
					}
				default:
					goto _9
				}
				goto _8
			}
		_9:
			if p.c().tok == RBRACE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _6
			}
		}
		goto _1
	_6:
		goto _0
	}
_1:
	return &ExprSwitchStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionNode represents

//	Expression = LogicalAndExpression { "||" LogicalAndExpression } .
type ExpressionNode = struct{}

func (p *parser) expression() *ExpressionNode {
	ix := p.ix
	// ebnf.Sequence: LogicalAndExpression { "||" LogicalAndExpression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.logicalAndExpression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "||" LogicalAndExpression }
		switch p.c().tok {
		case LOR:
			// ebnf.Sequence: "||" LogicalAndExpression
			ix := p.ix
			if p.c().tok == LOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.logicalAndExpression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionListNode represents

//	ExpressionList = Expression { "," Expression } .
type ExpressionListNode = struct{}

func (p *parser) expressionList() *ExpressionListNode {
	ix := p.ix
	// ebnf.Sequence: Expression { "," Expression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," Expression }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," Expression
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ExpressionListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionListPreBlockNode represents

//	ExpressionListPreBlock = ExpressionPreBlock { "," ExpressionPreBlock } .
type ExpressionListPreBlockNode = struct{}

func (p *parser) expressionListPreBlock() *ExpressionListPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: ExpressionPreBlock { "," ExpressionPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," ExpressionPreBlock }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," ExpressionPreBlock
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ExpressionListPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionPreBlockNode represents

//	ExpressionPreBlock = LogicalAndExpressionPreBlock { "||" LogicalAndExpressionPreBlock } | Expression .
type ExpressionPreBlockNode = struct{}

func (p *parser) expressionPreBlock() *ExpressionPreBlockNode {
	ix := p.ix
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// single:
	// multi: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// ebnf.Alternative: LogicalAndExpressionPreBlock { "||" LogicalAndExpressionPreBlock } | Expression
	{
		// ebnf.Sequence: LogicalAndExpressionPreBlock { "||" LogicalAndExpressionPreBlock }
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.logicalAndExpressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		_3:
			// *ebnf.Repetition: { "||" LogicalAndExpressionPreBlock }
			switch p.c().tok {
			case LOR:
				// ebnf.Sequence: "||" LogicalAndExpressionPreBlock
				ix := p.ix
				if p.c().tok == LOR {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _4
				}
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.logicalAndExpressionPreBlock() == nil {
						p.back(ix)
						goto _4
					}
				default:
					p.back(ix)
					goto _4
				}
				goto _3
			}
		_4:
		}
		goto _1
	_2:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				goto _5
			}
		default:
			goto _5
		}
		goto _1
	_5:
		goto _0
	}
_1:
	return &ExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionStmtNode represents

//	ExpressionStmt = Expression .
type ExpressionStmtNode = struct{}

func (p *parser) expressionStmt() *ExpressionStmtNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ExpressionStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ExpressionStmtPreBlockNode represents

//	ExpressionStmtPreBlock = ExpressionPreBlock .
type ExpressionStmtPreBlockNode = struct{}

func (p *parser) expressionStmtPreBlock() *ExpressionStmtPreBlockNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expressionPreBlock() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ExpressionStmtPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FallthroughStmtNode represents

//	FallthroughStmt = "fallthrough" .
type FallthroughStmtNode = struct{}

func (p *parser) fallthroughStmt() *FallthroughStmtNode {
	ix := p.ix
	if p.c().tok == FALLTHROUGH {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &FallthroughStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FieldDeclNode represents

//	FieldDecl = ( IdentifierList Type | EmbeddedField ) [ Tag ] .
type FieldDeclNode = struct{}

func (p *parser) fieldDecl() *FieldDeclNode {
	ix := p.ix
	// ebnf.Sequence: ( IdentifierList Type | EmbeddedField ) [ Tag ]
	{
		ix := p.ix
		// *ebnf.Group: ( IdentifierList Type | EmbeddedField )
		switch p.c().tok {
		case IDENT, MUL:
			// false: IDENT
			// false: IDENT, MUL
			// single: MUL
			// multi: IDENT
			// ebnf.Alternative: IdentifierList Type | EmbeddedField
			{
				// ebnf.Sequence: IdentifierList Type
				{
					ix := p.ix
					switch p.c().tok {
					case IDENT:
						if p.identifierList() == nil {
							p.back(ix)
							goto _2
						}
					default:
						p.back(ix)
						goto _2
					}
					switch p.c().tok {
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
						if p.type1() == nil {
							p.back(ix)
							goto _2
						}
					default:
						p.back(ix)
						goto _2
					}
				}
				goto _1
			_2:
				switch p.c().tok {
				case IDENT, MUL:
					if p.embeddedField() == nil {
						goto _3
					}
				default:
					goto _3
				}
				goto _1
			_3:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Tag ]
		switch p.c().tok {
		case STRING:
			switch p.c().tok {
			case STRING:
				if p.tag() == nil {
					goto _4
				}
			default:
				goto _4
			}
		}
	_4:
	}
	return &FieldDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FieldNameNode represents

//	FieldName = identifier .
type FieldNameNode = struct{}

func (p *parser) fieldName() *FieldNameNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &FieldNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ForClauseNode represents

//	ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
type ForClauseNode = struct{}

func (p *parser) forClause() *ForClauseNode {
	ix := p.ix
	// ebnf.Sequence: [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ]
	{
		ix := p.ix
		// *ebnf.Option: [ InitStmt ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
				if p.initStmt() == nil {
					goto _1
				}
			}
		}
	_1:
		if p.c().tok == SEMICOLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Condition ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.condition() == nil {
					goto _2
				}
			default:
				goto _2
			}
		}
	_2:
		if p.c().tok == SEMICOLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ PostStmt ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
				if p.postStmt() == nil {
					goto _3
				}
			}
		}
	_3:
	}
	return &ForClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ForStmtNode represents

//	ForStmt = "for" ForClause Block | "for" RangeClause Block | "for" ExpressionPreBlock Block | "for" Block .
type ForStmtNode = struct{}

func (p *parser) forStmt() *ForStmtNode {
	ix := p.ix
	// false: FOR
	// false: FOR
	// false: FOR
	// false: FOR
	// single:
	// multi: FOR
	// ebnf.Alternative: "for" ForClause Block | "for" RangeClause Block | "for" ExpressionPreBlock Block | "for" Block
	{
		// ebnf.Sequence: "for" ForClause Block
		{
			ix := p.ix
			if p.c().tok == FOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, SEMICOLON, STRING, STRUCT, SUB, XOR:
				if p.forClause() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		goto _1
	_2:
		// ebnf.Sequence: "for" RangeClause Block
		{
			ix := p.ix
			if p.c().tok == FOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, RANGE, STRING, STRUCT, SUB, XOR:
				if p.rangeClause() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
		}
		goto _1
	_3:
		// ebnf.Sequence: "for" ExpressionPreBlock Block
		{
			ix := p.ix
			if p.c().tok == FOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionPreBlock() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
		}
		goto _1
	_4:
		// ebnf.Sequence: "for" Block
		{
			ix := p.ix
			if p.c().tok == FOR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _5
				}
			default:
				p.back(ix)
				goto _5
			}
		}
		goto _1
	_5:
		goto _0
	}
_1:
	return &ForStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionBodyNode represents

//	FunctionBody = Block .
type FunctionBodyNode = struct{}

func (p *parser) functionBody() *FunctionBodyNode {
	ix := p.ix
	switch p.c().tok {
	case LBRACE:
		if p.block() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &FunctionBodyNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionDeclNode represents

//	FunctionDecl = "func" FunctionName [ TypeParameters ] Signature [ FunctionBody ] .
type FunctionDeclNode = struct{}

func (p *parser) functionDecl() *FunctionDeclNode {
	ix := p.ix
	// ebnf.Sequence: "func" FunctionName [ TypeParameters ] Signature [ FunctionBody ]
	{
		ix := p.ix
		if p.c().tok == FUNC {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.functionName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ TypeParameters ]
		switch p.c().tok {
		case LBRACK:
			switch p.c().tok {
			case LBRACK:
				if p.typeParameters() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ FunctionBody ]
		switch p.c().tok {
		case LBRACE:
			switch p.c().tok {
			case LBRACE:
				if p.functionBody() == nil {
					goto _2
				}
			default:
				goto _2
			}
		}
	_2:
	}
	return &FunctionDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionLitNode represents

//	FunctionLit = "func" Signature FunctionBody .
type FunctionLitNode = struct{}

func (p *parser) functionLit() *FunctionLitNode {
	ix := p.ix
	// ebnf.Sequence: "func" Signature FunctionBody
	{
		ix := p.ix
		if p.c().tok == FUNC {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LBRACE:
			if p.functionBody() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &FunctionLitNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionNameNode represents

//	FunctionName = identifier .
type FunctionNameNode = struct{}

func (p *parser) functionName() *FunctionNameNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &FunctionNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// FunctionTypeNode represents

//	FunctionType = "func" Signature .
type FunctionTypeNode = struct{}

func (p *parser) functionType() *FunctionTypeNode {
	ix := p.ix
	// ebnf.Sequence: "func" Signature
	{
		ix := p.ix
		if p.c().tok == FUNC {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &FunctionTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// GoStmtNode represents

//	GoStmt = "go" Expression .
type GoStmtNode = struct{}

func (p *parser) goStmt() *GoStmtNode {
	ix := p.ix
	// ebnf.Sequence: "go" Expression
	{
		ix := p.ix
		if p.c().tok == GO {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &GoStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// GotoStmtNode represents

//	GotoStmt = "goto" Label .
type GotoStmtNode = struct{}

func (p *parser) gotoStmt() *GotoStmtNode {
	ix := p.ix
	// ebnf.Sequence: "goto" Label
	{
		ix := p.ix
		if p.c().tok == GOTO {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.label() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &GotoStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// IdentifierListNode represents

//	IdentifierList = identifier { "," identifier } .
type IdentifierListNode = struct{}

func (p *parser) identifierList() *IdentifierListNode {
	ix := p.ix
	// ebnf.Sequence: identifier { "," identifier }
	{
		ix := p.ix
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," identifier }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," identifier
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			if p.c().tok == IDENT {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &IdentifierListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// IfStmtNode represents

//	IfStmt = "if" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ] | "if" SimpleStmt ";" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ] .
type IfStmtNode = struct{}

func (p *parser) ifStmt() *IfStmtNode {
	ix := p.ix
	// false: IF
	// false: IF
	// single:
	// multi: IF
	// ebnf.Alternative: "if" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ] | "if" SimpleStmt ";" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ]
	{
		// ebnf.Sequence: "if" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ]
		{
			ix := p.ix
			if p.c().tok == IF {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			// *ebnf.Option: [ "else" ( IfStmt | Block ) ]
			switch p.c().tok {
			case ELSE:
				// ebnf.Sequence: "else" ( IfStmt | Block )
				{
					ix := p.ix
					if p.c().tok == ELSE {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
					// *ebnf.Group: ( IfStmt | Block )
					switch p.c().tok {
					case IF, LBRACE:
						// true: IF
						// true: LBRACE
						// single: IF, LBRACE
						// multi:
						// ebnf.Alternative: IfStmt | Block
						{
							switch p.c().tok {
							case IF:
								if p.ifStmt() == nil {
									goto _5
								}
							default:
								goto _5
							}
							goto _4
						_5:
							switch p.c().tok {
							case LBRACE:
								if p.block() == nil {
									goto _6
								}
							default:
								goto _6
							}
							goto _4
						_6:
							p.back(ix)
							goto _3
						}
					_4:
						;
					default:
						p.back(ix)
						goto _3
					}
				}
			}
		_3:
		}
		goto _1
	_2:
		// ebnf.Sequence: "if" SimpleStmt ";" ExpressionPreBlock Block [ "else" ( IfStmt | Block ) ]
		{
			ix := p.ix
			if p.c().tok == IF {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _7
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
				if p.simpleStmt() == nil {
					p.back(ix)
					goto _7
				}
			}
			if p.c().tok == SEMICOLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _7
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionPreBlock() == nil {
					p.back(ix)
					goto _7
				}
			default:
				p.back(ix)
				goto _7
			}
			switch p.c().tok {
			case LBRACE:
				if p.block() == nil {
					p.back(ix)
					goto _7
				}
			default:
				p.back(ix)
				goto _7
			}
			// *ebnf.Option: [ "else" ( IfStmt | Block ) ]
			switch p.c().tok {
			case ELSE:
				// ebnf.Sequence: "else" ( IfStmt | Block )
				{
					ix := p.ix
					if p.c().tok == ELSE {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _8
					}
					// *ebnf.Group: ( IfStmt | Block )
					switch p.c().tok {
					case IF, LBRACE:
						// true: IF
						// true: LBRACE
						// single: IF, LBRACE
						// multi:
						// ebnf.Alternative: IfStmt | Block
						{
							switch p.c().tok {
							case IF:
								if p.ifStmt() == nil {
									goto _10
								}
							default:
								goto _10
							}
							goto _9
						_10:
							switch p.c().tok {
							case LBRACE:
								if p.block() == nil {
									goto _11
								}
							default:
								goto _11
							}
							goto _9
						_11:
							p.back(ix)
							goto _8
						}
					_9:
						;
					default:
						p.back(ix)
						goto _8
					}
				}
			}
		_8:
		}
		goto _1
	_7:
		goto _0
	}
_1:
	return &IfStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ImportDeclNode represents

//	ImportDecl = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
type ImportDeclNode = struct{}

func (p *parser) importDecl() *ImportDeclNode {
	ix := p.ix
	// ebnf.Sequence: "import" ( ImportSpec | "(" { ImportSpec ";" } ")" )
	{
		ix := p.ix
		if p.c().tok == IMPORT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( ImportSpec | "(" { ImportSpec ";" } ")" )
		switch p.c().tok {
		case IDENT, LPAREN, PERIOD, STRING:
			// true: IDENT, PERIOD, STRING
			// true: LPAREN
			// single: IDENT, LPAREN, PERIOD, STRING
			// multi:
			// ebnf.Alternative: ImportSpec | "(" { ImportSpec ";" } ")"
			{
				switch p.c().tok {
				case IDENT, PERIOD, STRING:
					if p.importSpec() == nil {
						goto _2
					}
				default:
					goto _2
				}
				goto _1
			_2:
				// ebnf.Sequence: "(" { ImportSpec ";" } ")"
				{
					ix := p.ix
					if p.c().tok == LPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				_4:
					// *ebnf.Repetition: { ImportSpec ";" }
					switch p.c().tok {
					case IDENT, PERIOD, STRING:
						// ebnf.Sequence: ImportSpec ";"
						ix := p.ix
						switch p.c().tok {
						case IDENT, PERIOD, STRING:
							if p.importSpec() == nil {
								p.back(ix)
								goto _5
							}
						default:
							p.back(ix)
							goto _5
						}
						if p.c().tok == SEMICOLON {
							p.ix++
							p.budget--
						} else {
							p.back(ix)
							goto _5
						}
						goto _4
					}
				_5:
					if p.c().tok == RPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				}
				goto _1
			_3:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ImportDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ImportPathNode represents

//	ImportPath = string_lit .
type ImportPathNode = struct{}

func (p *parser) importPath() *ImportPathNode {
	ix := p.ix
	if p.c().tok == STRING {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &ImportPathNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ImportSpecNode represents

//	ImportSpec = [ "." | PackageName ] ImportPath .
type ImportSpecNode = struct{}

func (p *parser) importSpec() *ImportSpecNode {
	ix := p.ix
	// ebnf.Sequence: [ "." | PackageName ] ImportPath
	{
		ix := p.ix
		// *ebnf.Option: [ "." | PackageName ]
		switch p.c().tok {
		case IDENT, PERIOD:
			// true: PERIOD
			// true: IDENT
			// single: IDENT, PERIOD
			// multi:
			// ebnf.Alternative: "." | PackageName
			{
				if p.c().tok == PERIOD {
					p.ix++
					p.budget--
				} else {
					goto _3
				}
				goto _2
			_3:
				switch p.c().tok {
				case IDENT:
					if p.packageName() == nil {
						goto _4
					}
				default:
					goto _4
				}
				goto _2
			_4:
				goto _1
			}
		_2:
		}
	_1:
		switch p.c().tok {
		case STRING:
			if p.importPath() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ImportSpecNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// IncDecStmtNode represents

//	IncDecStmt = Expression ( "++" | "--" ) .
type IncDecStmtNode = struct{}

func (p *parser) incDecStmt() *IncDecStmtNode {
	ix := p.ix
	// ebnf.Sequence: Expression ( "++" | "--" )
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( "++" | "--" )
		switch p.c().tok {
		case DEC, INC:
			// true: INC
			// true: DEC
			// single: DEC, INC
			// multi:
			// ebnf.Alternative: "++" | "--"
			{
				if p.c().tok == INC {
					p.ix++
					p.budget--
				} else {
					goto _2
				}
				goto _1
			_2:
				if p.c().tok == DEC {
					p.ix++
					p.budget--
				} else {
					goto _3
				}
				goto _1
			_3:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
	}
	return &IncDecStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// IndexNode represents

//	Index = "[" Expression "]" .
type IndexNode = struct{}

func (p *parser) index() *IndexNode {
	ix := p.ix
	// ebnf.Sequence: "[" Expression "]"
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &IndexNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// InitStmtNode represents

//	InitStmt = SimpleStmt .
type InitStmtNode = struct{}

func (p *parser) initStmt() *InitStmtNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
		if p.simpleStmt() == nil {
			goto _0
		}
	}
	return &InitStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// InterfaceElemNode represents

//	InterfaceElem = MethodElem | TypeElem .
type InterfaceElemNode = struct{}

func (p *parser) interfaceElem() *InterfaceElemNode {
	ix := p.ix
	// false: IDENT
	// false: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE
	// single: ARROW, CHAN, FUNC, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE
	// multi: IDENT
	// ebnf.Alternative: MethodElem | TypeElem
	{
		switch p.c().tok {
		case IDENT:
			if p.methodElem() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			if p.typeElem() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &InterfaceElemNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// InterfaceTypeNode represents

//	InterfaceType = "interface" "{" [ InterfaceElem { ";" InterfaceElem } [ ";" ] ] "}" .
type InterfaceTypeNode = struct{}

func (p *parser) interfaceType() *InterfaceTypeNode {
	ix := p.ix
	// ebnf.Sequence: "interface" "{" [ InterfaceElem { ";" InterfaceElem } [ ";" ] ] "}"
	{
		ix := p.ix
		if p.c().tok == INTERFACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ InterfaceElem { ";" InterfaceElem } [ ";" ] ]
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			// ebnf.Sequence: InterfaceElem { ";" InterfaceElem } [ ";" ]
			{
				ix := p.ix
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
					if p.interfaceElem() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
			_2:
				// *ebnf.Repetition: { ";" InterfaceElem }
				switch p.c().tok {
				case SEMICOLON:
					// ebnf.Sequence: ";" InterfaceElem
					ix := p.ix
					if p.c().tok == SEMICOLON {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
					switch p.c().tok {
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
						if p.interfaceElem() == nil {
							p.back(ix)
							goto _3
						}
					default:
						p.back(ix)
						goto _3
					}
					goto _2
				}
			_3:
				// *ebnf.Option: [ ";" ]
				switch p.c().tok {
				case SEMICOLON:
					if p.c().tok == SEMICOLON {
						p.ix++
						p.budget--
					} else {
						goto _4
					}
				}
			_4:
			}
		}
	_1:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &InterfaceTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// KeyNode represents

//	Key = Expression | FieldName | LiteralValue .
type KeyNode = struct{}

func (p *parser) key() *KeyNode {
	ix := p.ix
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// false: IDENT
	// true: LBRACE
	// single: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// multi: IDENT
	// ebnf.Alternative: Expression | FieldName | LiteralValue
	{
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case IDENT:
			if p.fieldName() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case LBRACE:
			if p.literalValue() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		goto _0
	}
_1:
	return &KeyNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// KeyTypeNode represents

//	KeyType = Type .
type KeyTypeNode = struct{}

func (p *parser) keyType() *KeyTypeNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
		if p.type1() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &KeyTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// KeyedElementNode represents

//	KeyedElement = [ Key ":" ] Element .
type KeyedElementNode = struct{}

func (p *parser) keyedElement() *KeyedElementNode {
	ix := p.ix
	// ebnf.Sequence: [ Key ":" ] Element
	{
		ix := p.ix
		// *ebnf.Option: [ Key ":" ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// ebnf.Sequence: Key ":"
			{
				ix := p.ix
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.key() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
				if p.c().tok == COLON {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
			}
		}
	_1:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.element() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &KeyedElementNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LabelNode represents

//	Label = identifier .
type LabelNode = struct{}

func (p *parser) label() *LabelNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &LabelNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LabeledStmtNode represents

//	LabeledStmt = Label ":" Statement .
type LabeledStmtNode = struct{}

func (p *parser) labeledStmt() *LabeledStmtNode {
	ix := p.ix
	// ebnf.Sequence: Label ":" Statement
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.label() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == COLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statement() == nil {
				p.back(ix)
				goto _0
			}
		}
	}
	return &LabeledStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralNode represents

//	Literal = BasicLit | CompositeLit | FunctionLit .
type LiteralNode = struct{}

func (p *parser) literal() *LiteralNode {
	ix := p.ix
	// true: CHAR, FLOAT, IMAG, INT, STRING
	// true: IDENT, LBRACK, MAP, STRUCT
	// true: FUNC
	// single: CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, MAP, STRING, STRUCT
	// multi:
	// ebnf.Alternative: BasicLit | CompositeLit | FunctionLit
	{
		switch p.c().tok {
		case CHAR, FLOAT, IMAG, INT, STRING:
			if p.basicLit() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case IDENT, LBRACK, MAP, STRUCT:
			if p.compositeLit() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case FUNC:
			if p.functionLit() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		goto _0
	}
_1:
	return &LiteralNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralPreBlockNode represents

//	LiteralPreBlock = BasicLit | CompositeLitPreBlock | FunctionLit .
type LiteralPreBlockNode = struct{}

func (p *parser) literalPreBlock() *LiteralPreBlockNode {
	ix := p.ix
	// true: CHAR, FLOAT, IMAG, INT, STRING
	// true: LBRACK, MAP, STRUCT
	// true: FUNC
	// single: CHAR, FLOAT, FUNC, IMAG, INT, LBRACK, MAP, STRING, STRUCT
	// multi:
	// ebnf.Alternative: BasicLit | CompositeLitPreBlock | FunctionLit
	{
		switch p.c().tok {
		case CHAR, FLOAT, IMAG, INT, STRING:
			if p.basicLit() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case LBRACK, MAP, STRUCT:
			if p.compositeLitPreBlock() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case FUNC:
			if p.functionLit() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		goto _0
	}
_1:
	return &LiteralPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralTypeNode represents

//	LiteralType = StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType | TypeName [ TypeArgs ] .
type LiteralTypeNode = struct{}

func (p *parser) literalType() *LiteralTypeNode {
	ix := p.ix
	// true: STRUCT
	// false: LBRACK
	// false: LBRACK
	// false: LBRACK
	// true: MAP
	// true: IDENT
	// single: IDENT, MAP, STRUCT
	// multi: LBRACK
	// ebnf.Alternative: StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType | TypeName [ TypeArgs ]
	{
		switch p.c().tok {
		case STRUCT:
			if p.structType() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case LBRACK:
			if p.arrayType() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		// ebnf.Sequence: "[" "..." "]" ElementType
		{
			ix := p.ix
			if p.c().tok == LBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			if p.c().tok == ELLIPSIS {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			if p.c().tok == RBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
		}
		goto _1
	_4:
		switch p.c().tok {
		case LBRACK:
			if p.sliceType() == nil {
				goto _5
			}
		default:
			goto _5
		}
		goto _1
	_5:
		switch p.c().tok {
		case MAP:
			if p.mapType() == nil {
				goto _6
			}
		default:
			goto _6
		}
		goto _1
	_6:
		// ebnf.Sequence: TypeName [ TypeArgs ]
		{
			ix := p.ix
			switch p.c().tok {
			case IDENT:
				if p.typeName() == nil {
					p.back(ix)
					goto _7
				}
			default:
				p.back(ix)
				goto _7
			}
			// *ebnf.Option: [ TypeArgs ]
			switch p.c().tok {
			case LBRACK:
				switch p.c().tok {
				case LBRACK:
					if p.typeArgs() == nil {
						goto _8
					}
				default:
					goto _8
				}
			}
		_8:
		}
		goto _1
	_7:
		goto _0
	}
_1:
	return &LiteralTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralTypePreBlockNode represents

//	LiteralTypePreBlock = StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType .
type LiteralTypePreBlockNode = struct{}

func (p *parser) literalTypePreBlock() *LiteralTypePreBlockNode {
	ix := p.ix
	// true: STRUCT
	// false: LBRACK
	// false: LBRACK
	// false: LBRACK
	// true: MAP
	// single: MAP, STRUCT
	// multi: LBRACK
	// ebnf.Alternative: StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType
	{
		switch p.c().tok {
		case STRUCT:
			if p.structType() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case LBRACK:
			if p.arrayType() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		// ebnf.Sequence: "[" "..." "]" ElementType
		{
			ix := p.ix
			if p.c().tok == LBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			if p.c().tok == ELLIPSIS {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			if p.c().tok == RBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.elementType() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
		}
		goto _1
	_4:
		switch p.c().tok {
		case LBRACK:
			if p.sliceType() == nil {
				goto _5
			}
		default:
			goto _5
		}
		goto _1
	_5:
		switch p.c().tok {
		case MAP:
			if p.mapType() == nil {
				goto _6
			}
		default:
			goto _6
		}
		goto _1
	_6:
		goto _0
	}
_1:
	return &LiteralTypePreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LiteralValueNode represents

//	LiteralValue = "{" [ ElementList [ "," ] ] "}" .
type LiteralValueNode = struct{}

func (p *parser) literalValue() *LiteralValueNode {
	ix := p.ix
	// ebnf.Sequence: "{" [ ElementList [ "," ] ] "}"
	{
		ix := p.ix
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ ElementList [ "," ] ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// ebnf.Sequence: ElementList [ "," ]
			{
				ix := p.ix
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.elementList() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
				// *ebnf.Option: [ "," ]
				switch p.c().tok {
				case COMMA:
					if p.c().tok == COMMA {
						p.ix++
						p.budget--
					} else {
						goto _2
					}
				}
			_2:
			}
		}
	_1:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &LiteralValueNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LogicalAndExpressionNode represents

//	LogicalAndExpression = RelationalExpression { "&&" RelationalExpression } .
type LogicalAndExpressionNode = struct{}

func (p *parser) logicalAndExpression() *LogicalAndExpressionNode {
	ix := p.ix
	// ebnf.Sequence: RelationalExpression { "&&" RelationalExpression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.relationalExpression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "&&" RelationalExpression }
		switch p.c().tok {
		case LAND:
			// ebnf.Sequence: "&&" RelationalExpression
			ix := p.ix
			if p.c().tok == LAND {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.relationalExpression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &LogicalAndExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// LogicalAndExpressionPreBlockNode represents

//	LogicalAndExpressionPreBlock = RelationalExpressionPreBlock { "&&" RelationalExpressionPreBlock } .
type LogicalAndExpressionPreBlockNode = struct{}

func (p *parser) logicalAndExpressionPreBlock() *LogicalAndExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: RelationalExpressionPreBlock { "&&" RelationalExpressionPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.relationalExpressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "&&" RelationalExpressionPreBlock }
		switch p.c().tok {
		case LAND:
			// ebnf.Sequence: "&&" RelationalExpressionPreBlock
			ix := p.ix
			if p.c().tok == LAND {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.relationalExpressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &LogicalAndExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MapTypeNode represents

//	MapType = "map" "[" KeyType "]" ElementType .
type MapTypeNode = struct{}

func (p *parser) mapType() *MapTypeNode {
	ix := p.ix
	// ebnf.Sequence: "map" "[" KeyType "]" ElementType
	{
		ix := p.ix
		if p.c().tok == MAP {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.keyType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.elementType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &MapTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MethodDeclNode represents

//	MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
type MethodDeclNode = struct{}

func (p *parser) methodDecl() *MethodDeclNode {
	ix := p.ix
	// ebnf.Sequence: "func" Receiver MethodName Signature [ FunctionBody ]
	{
		ix := p.ix
		if p.c().tok == FUNC {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.receiver() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.methodName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ FunctionBody ]
		switch p.c().tok {
		case LBRACE:
			switch p.c().tok {
			case LBRACE:
				if p.functionBody() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &MethodDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MethodElemNode represents

//	MethodElem = MethodName Signature .
type MethodElemNode = struct{}

func (p *parser) methodElem() *MethodElemNode {
	ix := p.ix
	// ebnf.Sequence: MethodName Signature
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.methodName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case LPAREN:
			if p.signature() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &MethodElemNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MethodExprNode represents

//	MethodExpr = ReceiverType "." MethodName .
type MethodExprNode = struct{}

func (p *parser) methodExpr() *MethodExprNode {
	ix := p.ix
	// ebnf.Sequence: ReceiverType "." MethodName
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.receiverType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.methodName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &MethodExprNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MethodNameNode represents

//	MethodName = identifier .
type MethodNameNode = struct{}

func (p *parser) methodName() *MethodNameNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &MethodNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MulOpNode represents

//	MulOp = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .
type MulOpNode = struct{}

func (p *parser) mulOp() *MulOpNode {
	ix := p.ix
	// true: MUL
	// true: QUO
	// true: REM
	// true: SHL
	// true: SHR
	// true: AND
	// true: AND_NOT
	// single: AND, AND_NOT, MUL, QUO, REM, SHL, SHR
	// multi:
	// ebnf.Alternative: "*" | "/" | "%" | "<<" | ">>" | "&" | "&^"
	{
		if p.c().tok == MUL {
			p.ix++
			p.budget--
		} else {
			goto _2
		}
		goto _1
	_2:
		if p.c().tok == QUO {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		if p.c().tok == REM {
			p.ix++
			p.budget--
		} else {
			goto _4
		}
		goto _1
	_4:
		if p.c().tok == SHL {
			p.ix++
			p.budget--
		} else {
			goto _5
		}
		goto _1
	_5:
		if p.c().tok == SHR {
			p.ix++
			p.budget--
		} else {
			goto _6
		}
		goto _1
	_6:
		if p.c().tok == AND {
			p.ix++
			p.budget--
		} else {
			goto _7
		}
		goto _1
	_7:
		if p.c().tok == AND_NOT {
			p.ix++
			p.budget--
		} else {
			goto _8
		}
		goto _1
	_8:
		goto _0
	}
_1:
	return &MulOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MultiplicativeExpressionNode represents

//	MultiplicativeExpression = UnaryExpr { MulOp UnaryExpr } .
type MultiplicativeExpressionNode = struct{}

func (p *parser) multiplicativeExpression() *MultiplicativeExpressionNode {
	ix := p.ix
	// ebnf.Sequence: UnaryExpr { MulOp UnaryExpr }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.unaryExpr() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { MulOp UnaryExpr }
		switch p.c().tok {
		case AND, AND_NOT, MUL, QUO, REM, SHL, SHR:
			// ebnf.Sequence: MulOp UnaryExpr
			ix := p.ix
			switch p.c().tok {
			case AND, AND_NOT, MUL, QUO, REM, SHL, SHR:
				if p.mulOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExpr() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &MultiplicativeExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// MultiplicativeExpressionPreBlockNode represents

//	MultiplicativeExpressionPreBlock = UnaryExprPreBlockPreBlock { MulOp UnaryExprPreBlockPreBlock } .
type MultiplicativeExpressionPreBlockNode = struct{}

func (p *parser) multiplicativeExpressionPreBlock() *MultiplicativeExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: UnaryExprPreBlockPreBlock { MulOp UnaryExprPreBlockPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.unaryExprPreBlockPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { MulOp UnaryExprPreBlockPreBlock }
		switch p.c().tok {
		case AND, AND_NOT, MUL, QUO, REM, SHL, SHR:
			// ebnf.Sequence: MulOp UnaryExprPreBlockPreBlock
			ix := p.ix
			switch p.c().tok {
			case AND, AND_NOT, MUL, QUO, REM, SHL, SHR:
				if p.mulOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExprPreBlockPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &MultiplicativeExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// OperandNode represents

//	Operand = Literal | OperandName [ TypeArgs ] | "(" Expression ")" .
type OperandNode = struct{}

func (p *parser) operand() *OperandNode {
	ix := p.ix
	// false: CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, MAP, STRING, STRUCT
	// false: IDENT
	// true: LPAREN
	// single: CHAR, FLOAT, FUNC, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT
	// multi: IDENT
	// ebnf.Alternative: Literal | OperandName [ TypeArgs ] | "(" Expression ")"
	{
		switch p.c().tok {
		case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, MAP, STRING, STRUCT:
			if p.literal() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		// ebnf.Sequence: OperandName [ TypeArgs ]
		{
			ix := p.ix
			switch p.c().tok {
			case IDENT:
				if p.operandName() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
			// *ebnf.Option: [ TypeArgs ]
			switch p.c().tok {
			case LBRACK:
				switch p.c().tok {
				case LBRACK:
					if p.typeArgs() == nil {
						goto _4
					}
				default:
					goto _4
				}
			}
		_4:
		}
		goto _1
	_3:
		// ebnf.Sequence: "(" Expression ")"
		{
			ix := p.ix
			if p.c().tok == LPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _5
				}
			default:
				p.back(ix)
				goto _5
			}
			if p.c().tok == RPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
		}
		goto _1
	_5:
		goto _0
	}
_1:
	return &OperandNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// OperandNameNode represents

//	OperandName = QualifiedIdent | identifier .
type OperandNameNode = struct{}

func (p *parser) operandName() *OperandNameNode {
	ix := p.ix
	// false: IDENT
	// false: IDENT
	// single:
	// multi: IDENT
	// ebnf.Alternative: QualifiedIdent | identifier
	{
		switch p.c().tok {
		case IDENT:
			if p.qualifiedIdent() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &OperandNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// OperandPreBlockNode represents

//	OperandPreBlock = LiteralPreBlock | OperandName [ TypeArgs ] | "(" Expression ")" .
type OperandPreBlockNode = struct{}

func (p *parser) operandPreBlock() *OperandPreBlockNode {
	ix := p.ix
	// true: CHAR, FLOAT, FUNC, IMAG, INT, LBRACK, MAP, STRING, STRUCT
	// true: IDENT
	// true: LPAREN
	// single: CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT
	// multi:
	// ebnf.Alternative: LiteralPreBlock | OperandName [ TypeArgs ] | "(" Expression ")"
	{
		switch p.c().tok {
		case CHAR, FLOAT, FUNC, IMAG, INT, LBRACK, MAP, STRING, STRUCT:
			if p.literalPreBlock() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		// ebnf.Sequence: OperandName [ TypeArgs ]
		{
			ix := p.ix
			switch p.c().tok {
			case IDENT:
				if p.operandName() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
			// *ebnf.Option: [ TypeArgs ]
			switch p.c().tok {
			case LBRACK:
				switch p.c().tok {
				case LBRACK:
					if p.typeArgs() == nil {
						goto _4
					}
				default:
					goto _4
				}
			}
		_4:
		}
		goto _1
	_3:
		// ebnf.Sequence: "(" Expression ")"
		{
			ix := p.ix
			if p.c().tok == LPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _5
				}
			default:
				p.back(ix)
				goto _5
			}
			if p.c().tok == RPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
		}
		goto _1
	_5:
		goto _0
	}
_1:
	return &OperandPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PackageClauseNode represents

//	PackageClause = "package" PackageName .
type PackageClauseNode = struct{}

func (p *parser) packageClause() *PackageClauseNode {
	ix := p.ix
	// ebnf.Sequence: "package" PackageName
	{
		ix := p.ix
		if p.c().tok == PACKAGE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.packageName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &PackageClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PackageNameNode represents

//	PackageName = identifier .
type PackageNameNode = struct{}

func (p *parser) packageName() *PackageNameNode {
	ix := p.ix
	if p.c().tok == IDENT {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &PackageNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ParameterDeclNode represents

//	ParameterDecl = identifier "..." Type | identifier Type | "..." Type | Type .
type ParameterDeclNode = struct{}

func (p *parser) parameterDecl() *ParameterDeclNode {
	ix := p.ix
	// false: IDENT
	// false: IDENT
	// true: ELLIPSIS
	// false: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
	// single: ARROW, CHAN, ELLIPSIS, FUNC, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
	// multi: IDENT
	// ebnf.Alternative: identifier "..." Type | identifier Type | "..." Type | Type
	{
		// ebnf.Sequence: identifier "..." Type
		{
			ix := p.ix
			if p.c().tok == IDENT {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			if p.c().tok == ELLIPSIS {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		goto _1
	_2:
		// ebnf.Sequence: identifier Type
		{
			ix := p.ix
			if p.c().tok == IDENT {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
		}
		goto _1
	_3:
		// ebnf.Sequence: "..." Type
		{
			ix := p.ix
			if p.c().tok == ELLIPSIS {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
		}
		goto _1
	_4:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				goto _5
			}
		default:
			goto _5
		}
		goto _1
	_5:
		goto _0
	}
_1:
	return &ParameterDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ParameterListNode represents

//	ParameterList = ParameterDecl { "," ParameterDecl } .
type ParameterListNode = struct{}

func (p *parser) parameterList() *ParameterListNode {
	ix := p.ix
	// ebnf.Sequence: ParameterDecl { "," ParameterDecl }
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, ELLIPSIS, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.parameterDecl() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," ParameterDecl }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," ParameterDecl
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, ELLIPSIS, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.parameterDecl() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &ParameterListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ParametersNode represents

//	Parameters = "(" [ ParameterList [ "," ] ] ")" .
type ParametersNode = struct{}

func (p *parser) parameters() *ParametersNode {
	ix := p.ix
	// ebnf.Sequence: "(" [ ParameterList [ "," ] ] ")"
	{
		ix := p.ix
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ ParameterList [ "," ] ]
		switch p.c().tok {
		case ARROW, CHAN, ELLIPSIS, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			// ebnf.Sequence: ParameterList [ "," ]
			{
				ix := p.ix
				switch p.c().tok {
				case ARROW, CHAN, ELLIPSIS, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.parameterList() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
				// *ebnf.Option: [ "," ]
				switch p.c().tok {
				case COMMA:
					if p.c().tok == COMMA {
						p.ix++
						p.budget--
					} else {
						goto _2
					}
				}
			_2:
			}
		}
	_1:
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &ParametersNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PointerTypeNode represents

//	PointerType = "*" BaseType .
type PointerTypeNode = struct{}

func (p *parser) pointerType() *PointerTypeNode {
	ix := p.ix
	// ebnf.Sequence: "*" BaseType
	{
		ix := p.ix
		if p.c().tok == MUL {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.baseType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &PointerTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PostStmtNode represents

//	PostStmt = SimpleStmtPreBlock .
type PostStmtNode = struct{}

func (p *parser) postStmt() *PostStmtNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
		if p.simpleStmtPreBlock() == nil {
			goto _0
		}
	}
	return &PostStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PrimaryExprNode represents

//	PrimaryExpr = ( Operand | Conversion | MethodExpr ) { Selector | Index | Slice | TypeAssertion | Arguments } .
type PrimaryExprNode = struct{}

func (p *parser) primaryExpr() *PrimaryExprNode {
	ix := p.ix
	// ebnf.Sequence: ( Operand | Conversion | MethodExpr ) { Selector | Index | Slice | TypeAssertion | Arguments }
	{
		ix := p.ix
		// *ebnf.Group: ( Operand | Conversion | MethodExpr )
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			// false: CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT
			// false: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
			// false: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
			// single: CHAR, FLOAT, IMAG, INT, STRING
			// multi: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
			// ebnf.Alternative: Operand | Conversion | MethodExpr
			{
				switch p.c().tok {
				case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT:
					if p.operand() == nil {
						goto _2
					}
				default:
					goto _2
				}
				goto _1
			_2:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.conversion() == nil {
						goto _3
					}
				default:
					goto _3
				}
				goto _1
			_3:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.methodExpr() == nil {
						goto _4
					}
				default:
					goto _4
				}
				goto _1
			_4:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
	_5:
		// *ebnf.Repetition: { Selector | Index | Slice | TypeAssertion | Arguments }
		switch p.c().tok {
		case LBRACK, LPAREN, PERIOD:
			// false: PERIOD
			// false: LBRACK
			// false: LBRACK
			// false: PERIOD
			// true: LPAREN
			// single: LPAREN
			// multi: LBRACK, PERIOD
			// ebnf.Alternative: Selector | Index | Slice | TypeAssertion | Arguments
			{
				switch p.c().tok {
				case PERIOD:
					if p.selector() == nil {
						goto _8
					}
				default:
					goto _8
				}
				goto _7
			_8:
				switch p.c().tok {
				case LBRACK:
					if p.index() == nil {
						goto _9
					}
				default:
					goto _9
				}
				goto _7
			_9:
				switch p.c().tok {
				case LBRACK:
					if p.slice() == nil {
						goto _10
					}
				default:
					goto _10
				}
				goto _7
			_10:
				switch p.c().tok {
				case PERIOD:
					if p.typeAssertion() == nil {
						goto _11
					}
				default:
					goto _11
				}
				goto _7
			_11:
				switch p.c().tok {
				case LPAREN:
					if p.arguments() == nil {
						goto _12
					}
				default:
					goto _12
				}
				goto _7
			_12:
				goto _6
			}
		_7:
			goto _5
		}
	_6:
	}
	return &PrimaryExprNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// PrimaryExprPreBlockNode represents

//	PrimaryExprPreBlock = ( OperandPreBlock | Conversion | MethodExpr ) { Selector | Index | Slice | TypeAssertion | Arguments } .
type PrimaryExprPreBlockNode = struct{}

func (p *parser) primaryExprPreBlock() *PrimaryExprPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: ( OperandPreBlock | Conversion | MethodExpr ) { Selector | Index | Slice | TypeAssertion | Arguments }
	{
		ix := p.ix
		// *ebnf.Group: ( OperandPreBlock | Conversion | MethodExpr )
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			// false: CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT
			// false: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
			// false: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
			// single: CHAR, FLOAT, IMAG, INT, STRING
			// multi: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
			// ebnf.Alternative: OperandPreBlock | Conversion | MethodExpr
			{
				switch p.c().tok {
				case CHAR, FLOAT, FUNC, IDENT, IMAG, INT, LBRACK, LPAREN, MAP, STRING, STRUCT:
					if p.operandPreBlock() == nil {
						goto _2
					}
				default:
					goto _2
				}
				goto _1
			_2:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.conversion() == nil {
						goto _3
					}
				default:
					goto _3
				}
				goto _1
			_3:
				switch p.c().tok {
				case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
					if p.methodExpr() == nil {
						goto _4
					}
				default:
					goto _4
				}
				goto _1
			_4:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
	_5:
		// *ebnf.Repetition: { Selector | Index | Slice | TypeAssertion | Arguments }
		switch p.c().tok {
		case LBRACK, LPAREN, PERIOD:
			// false: PERIOD
			// false: LBRACK
			// false: LBRACK
			// false: PERIOD
			// true: LPAREN
			// single: LPAREN
			// multi: LBRACK, PERIOD
			// ebnf.Alternative: Selector | Index | Slice | TypeAssertion | Arguments
			{
				switch p.c().tok {
				case PERIOD:
					if p.selector() == nil {
						goto _8
					}
				default:
					goto _8
				}
				goto _7
			_8:
				switch p.c().tok {
				case LBRACK:
					if p.index() == nil {
						goto _9
					}
				default:
					goto _9
				}
				goto _7
			_9:
				switch p.c().tok {
				case LBRACK:
					if p.slice() == nil {
						goto _10
					}
				default:
					goto _10
				}
				goto _7
			_10:
				switch p.c().tok {
				case PERIOD:
					if p.typeAssertion() == nil {
						goto _11
					}
				default:
					goto _11
				}
				goto _7
			_11:
				switch p.c().tok {
				case LPAREN:
					if p.arguments() == nil {
						goto _12
					}
				default:
					goto _12
				}
				goto _7
			_12:
				goto _6
			}
		_7:
			goto _5
		}
	_6:
	}
	return &PrimaryExprPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// QualifiedIdentNode represents

//	QualifiedIdent = PackageName "." identifier .
type QualifiedIdentNode = struct{}

func (p *parser) qualifiedIdent() *QualifiedIdentNode {
	ix := p.ix
	// ebnf.Sequence: PackageName "." identifier
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.packageName() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &QualifiedIdentNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RangeClauseNode represents

//	RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" ExpressionPreBlock .
type RangeClauseNode = struct{}

func (p *parser) rangeClause() *RangeClauseNode {
	ix := p.ix
	// ebnf.Sequence: [ ExpressionList "=" | IdentifierList ":=" ] "range" ExpressionPreBlock
	{
		ix := p.ix
		// *ebnf.Option: [ ExpressionList "=" | IdentifierList ":=" ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
			// false: IDENT
			// single: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
			// multi: IDENT
			// ebnf.Alternative: ExpressionList "=" | IdentifierList ":="
			{
				// ebnf.Sequence: ExpressionList "="
				{
					ix := p.ix
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.expressionList() == nil {
							p.back(ix)
							goto _3
						}
					default:
						p.back(ix)
						goto _3
					}
					if p.c().tok == ASSIGN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				}
				goto _2
			_3:
				// ebnf.Sequence: IdentifierList ":="
				{
					ix := p.ix
					switch p.c().tok {
					case IDENT:
						if p.identifierList() == nil {
							p.back(ix)
							goto _4
						}
					default:
						p.back(ix)
						goto _4
					}
					if p.c().tok == DEFINE {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _4
					}
				}
				goto _2
			_4:
				goto _1
			}
		_2:
		}
	_1:
		if p.c().tok == RANGE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &RangeClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ReceiverNode represents

//	Receiver = Parameters .
type ReceiverNode = struct{}

func (p *parser) receiver() *ReceiverNode {
	ix := p.ix
	switch p.c().tok {
	case LPAREN:
		if p.parameters() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ReceiverNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ReceiverTypeNode represents

//	ReceiverType = Type .
type ReceiverTypeNode = struct{}

func (p *parser) receiverType() *ReceiverTypeNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
		if p.type1() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &ReceiverTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RecvExprNode represents

//	RecvExpr = Expression .
type RecvExprNode = struct{}

func (p *parser) recvExpr() *RecvExprNode {
	ix := p.ix
	switch p.c().tok {
	case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
		if p.expression() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &RecvExprNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RecvStmtNode represents

//	RecvStmt = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr .
type RecvStmtNode = struct{}

func (p *parser) recvStmt() *RecvStmtNode {
	ix := p.ix
	// ebnf.Sequence: [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr
	{
		ix := p.ix
		// *ebnf.Option: [ ExpressionList "=" | IdentifierList ":=" ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
			// false: IDENT
			// single: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
			// multi: IDENT
			// ebnf.Alternative: ExpressionList "=" | IdentifierList ":="
			{
				// ebnf.Sequence: ExpressionList "="
				{
					ix := p.ix
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.expressionList() == nil {
							p.back(ix)
							goto _3
						}
					default:
						p.back(ix)
						goto _3
					}
					if p.c().tok == ASSIGN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				}
				goto _2
			_3:
				// ebnf.Sequence: IdentifierList ":="
				{
					ix := p.ix
					switch p.c().tok {
					case IDENT:
						if p.identifierList() == nil {
							p.back(ix)
							goto _4
						}
					default:
						p.back(ix)
						goto _4
					}
					if p.c().tok == DEFINE {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _4
					}
				}
				goto _2
			_4:
				goto _1
			}
		_2:
		}
	_1:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.recvExpr() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &RecvStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RelOpNode represents

//	RelOp = "==" | "!=" | "<" | "<=" | ">" | ">=" .
type RelOpNode = struct{}

func (p *parser) relOp() *RelOpNode {
	ix := p.ix
	// true: EQL
	// true: NEQ
	// true: LSS
	// true: LEQ
	// true: GTR
	// true: GEQ
	// single: EQL, GEQ, GTR, LEQ, LSS, NEQ
	// multi:
	// ebnf.Alternative: "==" | "!=" | "<" | "<=" | ">" | ">="
	{
		if p.c().tok == EQL {
			p.ix++
			p.budget--
		} else {
			goto _2
		}
		goto _1
	_2:
		if p.c().tok == NEQ {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		if p.c().tok == LSS {
			p.ix++
			p.budget--
		} else {
			goto _4
		}
		goto _1
	_4:
		if p.c().tok == LEQ {
			p.ix++
			p.budget--
		} else {
			goto _5
		}
		goto _1
	_5:
		if p.c().tok == GTR {
			p.ix++
			p.budget--
		} else {
			goto _6
		}
		goto _1
	_6:
		if p.c().tok == GEQ {
			p.ix++
			p.budget--
		} else {
			goto _7
		}
		goto _1
	_7:
		goto _0
	}
_1:
	return &RelOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RelationalExpressionNode represents

//	RelationalExpression = AdditiveExpression { RelOp AdditiveExpression } .
type RelationalExpressionNode = struct{}

func (p *parser) relationalExpression() *RelationalExpressionNode {
	ix := p.ix
	// ebnf.Sequence: AdditiveExpression { RelOp AdditiveExpression }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.additiveExpression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { RelOp AdditiveExpression }
		switch p.c().tok {
		case EQL, GEQ, GTR, LEQ, LSS, NEQ:
			// ebnf.Sequence: RelOp AdditiveExpression
			ix := p.ix
			switch p.c().tok {
			case EQL, GEQ, GTR, LEQ, LSS, NEQ:
				if p.relOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.additiveExpression() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &RelationalExpressionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// RelationalExpressionPreBlockNode represents

//	RelationalExpressionPreBlock = AdditiveExpressionPreBlock { RelOp AdditiveExpressionPreBlock } .
type RelationalExpressionPreBlockNode = struct{}

func (p *parser) relationalExpressionPreBlock() *RelationalExpressionPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: AdditiveExpressionPreBlock { RelOp AdditiveExpressionPreBlock }
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.additiveExpressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { RelOp AdditiveExpressionPreBlock }
		switch p.c().tok {
		case EQL, GEQ, GTR, LEQ, LSS, NEQ:
			// ebnf.Sequence: RelOp AdditiveExpressionPreBlock
			ix := p.ix
			switch p.c().tok {
			case EQL, GEQ, GTR, LEQ, LSS, NEQ:
				if p.relOp() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.additiveExpressionPreBlock() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &RelationalExpressionPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ResultNode represents

//	Result = Parameters | Type .
type ResultNode = struct{}

func (p *parser) result() *ResultNode {
	ix := p.ix
	// false: LPAREN
	// false: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
	// single: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, MAP, MUL, STRUCT
	// multi: LPAREN
	// ebnf.Alternative: Parameters | Type
	{
		switch p.c().tok {
		case LPAREN:
			if p.parameters() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &ResultNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ReturnStmtNode represents

//	ReturnStmt = "return" [ ExpressionList ] .
type ReturnStmtNode = struct{}

func (p *parser) returnStmt() *ReturnStmtNode {
	ix := p.ix
	// ebnf.Sequence: "return" [ ExpressionList ]
	{
		ix := p.ix
		if p.c().tok == RETURN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ ExpressionList ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expressionList() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &ReturnStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SelectStmtNode represents

//	SelectStmt = "select" "{" { CommClause } "}" .
type SelectStmtNode = struct{}

func (p *parser) selectStmt() *SelectStmtNode {
	ix := p.ix
	// ebnf.Sequence: "select" "{" { CommClause } "}"
	{
		ix := p.ix
		if p.c().tok == SELECT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { CommClause }
		switch p.c().tok {
		case CASE, DEFAULT:
			switch p.c().tok {
			case CASE, DEFAULT:
				if p.commClause() == nil {
					goto _2
				}
			default:
				goto _2
			}
			goto _1
		}
	_2:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &SelectStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SelectorNode represents

//	Selector = "." identifier .
type SelectorNode = struct{}

func (p *parser) selector() *SelectorNode {
	ix := p.ix
	// ebnf.Sequence: "." identifier
	{
		ix := p.ix
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &SelectorNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SendStmtNode represents

//	SendStmt = Channel "<-" Expression .
type SendStmtNode = struct{}

func (p *parser) sendStmt() *SendStmtNode {
	ix := p.ix
	// ebnf.Sequence: Channel "<-" Expression
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.channel() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == ARROW {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expression() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &SendStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SendStmtPreBlockNode represents

//	SendStmtPreBlock = Channel "<-" ExpressionPreBlock .
type SendStmtPreBlockNode = struct{}

func (p *parser) sendStmtPreBlock() *SendStmtPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: Channel "<-" ExpressionPreBlock
	{
		ix := p.ix
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.channel() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == ARROW {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &SendStmtPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ShortVarDeclNode represents

//	ShortVarDecl = IdentifierList ":=" ExpressionList .
type ShortVarDeclNode = struct{}

func (p *parser) shortVarDecl() *ShortVarDeclNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList ":=" ExpressionList
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == DEFINE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ShortVarDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// ShortVarDeclPreBlockNode represents

//	ShortVarDeclPreBlock = IdentifierList ":=" ExpressionListPreBlock .
type ShortVarDeclPreBlockNode = struct{}

func (p *parser) shortVarDeclPreBlock() *ShortVarDeclPreBlockNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList ":=" ExpressionListPreBlock
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == DEFINE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionListPreBlock() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &ShortVarDeclPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SignatureNode represents

//	Signature = Parameters [ Result ] .
type SignatureNode = struct{}

func (p *parser) signature() *SignatureNode {
	ix := p.ix
	// ebnf.Sequence: Parameters [ Result ]
	{
		ix := p.ix
		switch p.c().tok {
		case LPAREN:
			if p.parameters() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ Result ]
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.result() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
	}
	return &SignatureNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SimpleStmtNode represents

//	SimpleStmt = Assignment | ShortVarDecl | IncDecStmt | SendStmt | ExpressionStmt | EmptyStmt .
type SimpleStmtNode = struct{}

func (p *parser) simpleStmt() *SimpleStmtNode {
	ix := p.ix
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// false: IDENT
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// true:  /* ε */
	// single:  /* ε */
	// multi: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// ebnf.Alternative: Assignment | ShortVarDecl | IncDecStmt | SendStmt | ExpressionStmt | EmptyStmt
	{
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.assignment() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case IDENT:
			if p.shortVarDecl() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.incDecStmt() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.sendStmt() == nil {
				goto _5
			}
		default:
			goto _5
		}
		goto _1
	_5:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionStmt() == nil {
				goto _6
			}
		default:
			goto _6
		}
		goto _1
	_6:
		if p.emptyStmt() == nil {
			goto _7
		}
		goto _1
	_7:
		goto _0
	}
_1:
	return &SimpleStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SimpleStmtPreBlockNode represents

//	SimpleStmtPreBlock = AssignmentPreBlock | ShortVarDeclPreBlock | IncDecStmt | SendStmtPreBlock | ExpressionStmtPreBlock | EmptyStmt .
type SimpleStmtPreBlockNode = struct{}

func (p *parser) simpleStmtPreBlock() *SimpleStmtPreBlockNode {
	ix := p.ix
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// false: IDENT
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// true:  /* ε */
	// single:  /* ε */
	// multi: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR
	// ebnf.Alternative: AssignmentPreBlock | ShortVarDeclPreBlock | IncDecStmt | SendStmtPreBlock | ExpressionStmtPreBlock | EmptyStmt
	{
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.assignmentPreBlock() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case IDENT:
			if p.shortVarDeclPreBlock() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.incDecStmt() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.sendStmtPreBlock() == nil {
				goto _5
			}
		default:
			goto _5
		}
		goto _1
	_5:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
			if p.expressionStmtPreBlock() == nil {
				goto _6
			}
		default:
			goto _6
		}
		goto _1
	_6:
		if p.emptyStmt() == nil {
			goto _7
		}
		goto _1
	_7:
		goto _0
	}
_1:
	return &SimpleStmtPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SliceNode represents

//	Slice = "[" [ Expression ] ":" [ Expression ] "]" | "[" [ Expression ] ":" Expression ":" Expression "]" .
type SliceNode = struct{}

func (p *parser) slice() *SliceNode {
	ix := p.ix
	// false: LBRACK
	// false: LBRACK
	// single:
	// multi: LBRACK
	// ebnf.Alternative: "[" [ Expression ] ":" [ Expression ] "]" | "[" [ Expression ] ":" Expression ":" Expression "]"
	{
		// ebnf.Sequence: "[" [ Expression ] ":" [ Expression ] "]"
		{
			ix := p.ix
			if p.c().tok == LBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			// *ebnf.Option: [ Expression ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expression() == nil {
						goto _3
					}
				default:
					goto _3
				}
			}
		_3:
			if p.c().tok == COLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			// *ebnf.Option: [ Expression ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expression() == nil {
						goto _4
					}
				default:
					goto _4
				}
			}
		_4:
			if p.c().tok == RBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
		}
		goto _1
	_2:
		// ebnf.Sequence: "[" [ Expression ] ":" Expression ":" Expression "]"
		{
			ix := p.ix
			if p.c().tok == LBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			// *ebnf.Option: [ Expression ]
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
					if p.expression() == nil {
						goto _6
					}
				default:
					goto _6
				}
			}
		_6:
			if p.c().tok == COLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _5
				}
			default:
				p.back(ix)
				goto _5
			}
			if p.c().tok == COLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.expression() == nil {
					p.back(ix)
					goto _5
				}
			default:
				p.back(ix)
				goto _5
			}
			if p.c().tok == RBRACK {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
		}
		goto _1
	_5:
		goto _0
	}
_1:
	return &SliceNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SliceTypeNode represents

//	SliceType = "[" "]" ElementType .
type SliceTypeNode = struct{}

func (p *parser) sliceType() *SliceTypeNode {
	ix := p.ix
	// ebnf.Sequence: "[" "]" ElementType
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.elementType() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &SliceTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SourceFileNode represents

//	SourceFile = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
type SourceFileNode = struct{}

func (p *parser) sourceFile() *SourceFileNode {
	ix := p.ix
	// ebnf.Sequence: PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" }
	{
		ix := p.ix
		switch p.c().tok {
		case PACKAGE:
			if p.packageClause() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == SEMICOLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { ImportDecl ";" }
		switch p.c().tok {
		case IMPORT:
			// ebnf.Sequence: ImportDecl ";"
			ix := p.ix
			switch p.c().tok {
			case IMPORT:
				if p.importDecl() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			if p.c().tok == SEMICOLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	_3:
		// *ebnf.Repetition: { TopLevelDecl ";" }
		switch p.c().tok {
		case CONST, FUNC, TYPE, VAR:
			// ebnf.Sequence: TopLevelDecl ";"
			ix := p.ix
			switch p.c().tok {
			case CONST, FUNC, TYPE, VAR:
				if p.topLevelDecl() == nil {
					p.back(ix)
					goto _4
				}
			default:
				p.back(ix)
				goto _4
			}
			if p.c().tok == SEMICOLON {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _4
			}
			goto _3
		}
	_4:
	}
	return &SourceFileNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// StatementNode represents

//	Statement = Declaration | LabeledStmt | GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt | DeferStmt | SimpleStmt .
type StatementNode = struct{}

func (p *parser) statement() *StatementNode {
	ix := p.ix
	// true: CONST, TYPE, VAR
	// false: IDENT
	// true: GO
	// true: RETURN
	// true: BREAK
	// true: CONTINUE
	// true: GOTO
	// true: FALLTHROUGH
	// true: LBRACE
	// true: IF
	// true: SWITCH
	// true: SELECT
	// true: FOR
	// true: DEFER
	// false: ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */
	// single: ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */
	// multi: IDENT
	// ebnf.Alternative: Declaration | LabeledStmt | GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt | DeferStmt | SimpleStmt
	{
		switch p.c().tok {
		case CONST, TYPE, VAR:
			if p.declaration() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case IDENT:
			if p.labeledStmt() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case GO:
			if p.goStmt() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		switch p.c().tok {
		case RETURN:
			if p.returnStmt() == nil {
				goto _5
			}
		default:
			goto _5
		}
		goto _1
	_5:
		switch p.c().tok {
		case BREAK:
			if p.breakStmt() == nil {
				goto _6
			}
		default:
			goto _6
		}
		goto _1
	_6:
		switch p.c().tok {
		case CONTINUE:
			if p.continueStmt() == nil {
				goto _7
			}
		default:
			goto _7
		}
		goto _1
	_7:
		switch p.c().tok {
		case GOTO:
			if p.gotoStmt() == nil {
				goto _8
			}
		default:
			goto _8
		}
		goto _1
	_8:
		switch p.c().tok {
		case FALLTHROUGH:
			if p.fallthroughStmt() == nil {
				goto _9
			}
		default:
			goto _9
		}
		goto _1
	_9:
		switch p.c().tok {
		case LBRACE:
			if p.block() == nil {
				goto _10
			}
		default:
			goto _10
		}
		goto _1
	_10:
		switch p.c().tok {
		case IF:
			if p.ifStmt() == nil {
				goto _11
			}
		default:
			goto _11
		}
		goto _1
	_11:
		switch p.c().tok {
		case SWITCH:
			if p.switchStmt() == nil {
				goto _12
			}
		default:
			goto _12
		}
		goto _1
	_12:
		switch p.c().tok {
		case SELECT:
			if p.selectStmt() == nil {
				goto _13
			}
		default:
			goto _13
		}
		goto _1
	_13:
		switch p.c().tok {
		case FOR:
			if p.forStmt() == nil {
				goto _14
			}
		default:
			goto _14
		}
		goto _1
	_14:
		switch p.c().tok {
		case DEFER:
			if p.deferStmt() == nil {
				goto _15
			}
		default:
			goto _15
		}
		goto _1
	_15:
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
			if p.simpleStmt() == nil {
				goto _16
			}
		}
		goto _1
	_16:
		goto _0
	}
_1:
	return &StatementNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// StatementListNode represents

//	StatementList = [ Statement { ";" Statement } [ ";" ] ] .
type StatementListNode = struct{}

func (p *parser) statementList() *StatementListNode {
	ix := p.ix
	// *ebnf.Option: [ Statement { ";" Statement } [ ";" ] ]
	switch p.c().tok {
	case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
		// ebnf.Sequence: Statement { ";" Statement } [ ";" ]
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
				if p.statement() == nil {
					p.back(ix)
					goto _1
				}
			}
		_2:
			// *ebnf.Repetition: { ";" Statement }
			switch p.c().tok {
			case SEMICOLON:
				// ebnf.Sequence: ";" Statement
				ix := p.ix
				if p.c().tok == SEMICOLON {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _3
				}
				switch p.c().tok {
				case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
					if p.statement() == nil {
						p.back(ix)
						goto _3
					}
				}
				goto _2
			}
		_3:
			// *ebnf.Option: [ ";" ]
			switch p.c().tok {
			case SEMICOLON:
				if p.c().tok == SEMICOLON {
					p.ix++
					p.budget--
				} else {
					goto _4
				}
			}
		_4:
		}
	}
_1:
	return &StatementListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// StructTypeNode represents

//	StructType = "struct" "{" [ FieldDecl { ";" FieldDecl } [ ";" ] ] "}" .
type StructTypeNode = struct{}

func (p *parser) structType() *StructTypeNode {
	ix := p.ix
	// ebnf.Sequence: "struct" "{" [ FieldDecl { ";" FieldDecl } [ ";" ] ] "}"
	{
		ix := p.ix
		if p.c().tok == STRUCT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ FieldDecl { ";" FieldDecl } [ ";" ] ]
		switch p.c().tok {
		case IDENT, MUL:
			// ebnf.Sequence: FieldDecl { ";" FieldDecl } [ ";" ]
			{
				ix := p.ix
				switch p.c().tok {
				case IDENT, MUL:
					if p.fieldDecl() == nil {
						p.back(ix)
						goto _1
					}
				default:
					p.back(ix)
					goto _1
				}
			_2:
				// *ebnf.Repetition: { ";" FieldDecl }
				switch p.c().tok {
				case SEMICOLON:
					// ebnf.Sequence: ";" FieldDecl
					ix := p.ix
					if p.c().tok == SEMICOLON {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
					switch p.c().tok {
					case IDENT, MUL:
						if p.fieldDecl() == nil {
							p.back(ix)
							goto _3
						}
					default:
						p.back(ix)
						goto _3
					}
					goto _2
				}
			_3:
				// *ebnf.Option: [ ";" ]
				switch p.c().tok {
				case SEMICOLON:
					if p.c().tok == SEMICOLON {
						p.ix++
						p.budget--
					} else {
						goto _4
					}
				}
			_4:
			}
		}
	_1:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &StructTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// SwitchStmtNode represents

//	SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
type SwitchStmtNode = struct{}

func (p *parser) switchStmt() *SwitchStmtNode {
	ix := p.ix
	// false: SWITCH
	// false: SWITCH
	// single:
	// multi: SWITCH
	// ebnf.Alternative: ExprSwitchStmt | TypeSwitchStmt
	{
		switch p.c().tok {
		case SWITCH:
			if p.exprSwitchStmt() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case SWITCH:
			if p.typeSwitchStmt() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &SwitchStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TagNode represents

//	Tag = string_lit .
type TagNode = struct{}

func (p *parser) tag() *TagNode {
	ix := p.ix
	if p.c().tok == STRING {
		p.ix++
		p.budget--
	} else {
		goto _0
	}
	return &TagNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TopLevelDeclNode represents

//	TopLevelDecl = Declaration | FunctionDecl | MethodDecl .
type TopLevelDeclNode = struct{}

func (p *parser) topLevelDecl() *TopLevelDeclNode {
	ix := p.ix
	// true: CONST, TYPE, VAR
	// false: FUNC
	// false: FUNC
	// single: CONST, TYPE, VAR
	// multi: FUNC
	// ebnf.Alternative: Declaration | FunctionDecl | MethodDecl
	{
		switch p.c().tok {
		case CONST, TYPE, VAR:
			if p.declaration() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case FUNC:
			if p.functionDecl() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case FUNC:
			if p.methodDecl() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		goto _0
	}
_1:
	return &TopLevelDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeNode represents

//	Type = TypeName [ TypeArgs ] | TypeLit | "(" Type ")" .
type TypeNode = struct{}

func (p *parser) type1() *TypeNode {
	ix := p.ix
	// true: IDENT
	// true: ARROW, CHAN, FUNC, INTERFACE, LBRACK, MAP, MUL, STRUCT
	// true: LPAREN
	// single: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
	// multi:
	// ebnf.Alternative: TypeName [ TypeArgs ] | TypeLit | "(" Type ")"
	{
		// ebnf.Sequence: TypeName [ TypeArgs ]
		{
			ix := p.ix
			switch p.c().tok {
			case IDENT:
				if p.typeName() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			// *ebnf.Option: [ TypeArgs ]
			switch p.c().tok {
			case LBRACK:
				switch p.c().tok {
				case LBRACK:
					if p.typeArgs() == nil {
						goto _3
					}
				default:
					goto _3
				}
			}
		_3:
		}
		goto _1
	_2:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, INTERFACE, LBRACK, MAP, MUL, STRUCT:
			if p.typeLit() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		// ebnf.Sequence: "(" Type ")"
		{
			ix := p.ix
			if p.c().tok == LPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _5
				}
			default:
				p.back(ix)
				goto _5
			}
			if p.c().tok == RPAREN {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _5
			}
		}
		goto _1
	_5:
		goto _0
	}
_1:
	return &TypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeArgsNode represents

//	TypeArgs = "[" TypeList [ "," ] "]" .
type TypeArgsNode = struct{}

func (p *parser) typeArgs() *TypeArgsNode {
	ix := p.ix
	// ebnf.Sequence: "[" TypeList [ "," ] "]"
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.typeList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ "," ]
		switch p.c().tok {
		case COMMA:
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				goto _1
			}
		}
	_1:
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeArgsNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeAssertionNode represents

//	TypeAssertion = "." "(" Type ")" .
type TypeAssertionNode = struct{}

func (p *parser) typeAssertion() *TypeAssertionNode {
	ix := p.ix
	// ebnf.Sequence: "." "(" Type ")"
	{
		ix := p.ix
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeAssertionNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeCaseClauseNode represents

//	TypeCaseClause = TypeSwitchCase ":" StatementList .
type TypeCaseClauseNode = struct{}

func (p *parser) typeCaseClause() *TypeCaseClauseNode {
	ix := p.ix
	// ebnf.Sequence: TypeSwitchCase ":" StatementList
	{
		ix := p.ix
		switch p.c().tok {
		case CASE, DEFAULT:
			if p.typeSwitchCase() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == COLON {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ADD, AND, ARROW, BREAK, CHAN, CHAR, CONST, CONTINUE, DEFER, FALLTHROUGH, FLOAT, FOR, FUNC, GO, GOTO, IDENT, IF, IMAG, INT, INTERFACE, LBRACE, LBRACK, LPAREN, MAP, MUL, NOT, RETURN, SELECT, SEMICOLON, STRING, STRUCT, SUB, SWITCH, TYPE, VAR, XOR /* ε */ :
			if p.statementList() == nil {
				p.back(ix)
				goto _0
			}
		}
	}
	return &TypeCaseClauseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeConstraintNode represents

//	TypeConstraint = TypeElem .
type TypeConstraintNode = struct{}

func (p *parser) typeConstraint() *TypeConstraintNode {
	ix := p.ix
	switch p.c().tok {
	case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
		if p.typeElem() == nil {
			goto _0
		}
	default:
		goto _0
	}
	return &TypeConstraintNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeDeclNode represents

//	TypeDecl = "type" ( TypeSpec | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")" ) .
type TypeDeclNode = struct{}

func (p *parser) typeDecl() *TypeDeclNode {
	ix := p.ix
	// ebnf.Sequence: "type" ( TypeSpec | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")" )
	{
		ix := p.ix
		if p.c().tok == TYPE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( TypeSpec | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")" )
		switch p.c().tok {
		case IDENT, LPAREN:
			// true: IDENT
			// true: LPAREN
			// single: IDENT, LPAREN
			// multi:
			// ebnf.Alternative: TypeSpec | "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")"
			{
				switch p.c().tok {
				case IDENT:
					if p.typeSpec() == nil {
						goto _2
					}
				default:
					goto _2
				}
				goto _1
			_2:
				// ebnf.Sequence: "(" [ TypeSpec { ";" TypeSpec } [ ";" ] ] ")"
				{
					ix := p.ix
					if p.c().tok == LPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
					// *ebnf.Option: [ TypeSpec { ";" TypeSpec } [ ";" ] ]
					switch p.c().tok {
					case IDENT:
						// ebnf.Sequence: TypeSpec { ";" TypeSpec } [ ";" ]
						{
							ix := p.ix
							switch p.c().tok {
							case IDENT:
								if p.typeSpec() == nil {
									p.back(ix)
									goto _4
								}
							default:
								p.back(ix)
								goto _4
							}
						_5:
							// *ebnf.Repetition: { ";" TypeSpec }
							switch p.c().tok {
							case SEMICOLON:
								// ebnf.Sequence: ";" TypeSpec
								ix := p.ix
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									p.back(ix)
									goto _6
								}
								switch p.c().tok {
								case IDENT:
									if p.typeSpec() == nil {
										p.back(ix)
										goto _6
									}
								default:
									p.back(ix)
									goto _6
								}
								goto _5
							}
						_6:
							// *ebnf.Option: [ ";" ]
							switch p.c().tok {
							case SEMICOLON:
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									goto _7
								}
							}
						_7:
						}
					}
				_4:
					if p.c().tok == RPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				}
				goto _1
			_3:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
	}
	return &TypeDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeDefNode represents

//	TypeDef = identifier [ TypeParameters ] Type .
type TypeDefNode = struct{}

func (p *parser) typeDef() *TypeDefNode {
	ix := p.ix
	// ebnf.Sequence: identifier [ TypeParameters ] Type
	{
		ix := p.ix
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ TypeParameters ]
		switch p.c().tok {
		case LBRACK:
			switch p.c().tok {
			case LBRACK:
				if p.typeParameters() == nil {
					goto _1
				}
			default:
				goto _1
			}
		}
	_1:
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &TypeDefNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeElemNode represents

//	TypeElem = TypeTerm { "|" TypeTerm } .
type TypeElemNode = struct{}

func (p *parser) typeElem() *TypeElemNode {
	ix := p.ix
	// ebnf.Sequence: TypeTerm { "|" TypeTerm }
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			if p.typeTerm() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "|" TypeTerm }
		switch p.c().tok {
		case OR:
			// ebnf.Sequence: "|" TypeTerm
			ix := p.ix
			if p.c().tok == OR {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
				if p.typeTerm() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &TypeElemNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeListNode represents

//	TypeList = Type { "," Type } .
type TypeListNode = struct{}

func (p *parser) typeList() *TypeListNode {
	ix := p.ix
	// ebnf.Sequence: Type { "," Type }
	{
		ix := p.ix
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," Type }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," Type
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.type1() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &TypeListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeLitNode represents

//	TypeLit = ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | ChannelType .
type TypeLitNode = struct{}

func (p *parser) typeLit() *TypeLitNode {
	ix := p.ix
	// false: LBRACK
	// true: STRUCT
	// true: MUL
	// true: FUNC
	// true: INTERFACE
	// false: LBRACK
	// true: MAP
	// true: ARROW, CHAN
	// single: ARROW, CHAN, FUNC, INTERFACE, MAP, MUL, STRUCT
	// multi: LBRACK
	// ebnf.Alternative: ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | ChannelType
	{
		switch p.c().tok {
		case LBRACK:
			if p.arrayType() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case STRUCT:
			if p.structType() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		switch p.c().tok {
		case MUL:
			if p.pointerType() == nil {
				goto _4
			}
		default:
			goto _4
		}
		goto _1
	_4:
		switch p.c().tok {
		case FUNC:
			if p.functionType() == nil {
				goto _5
			}
		default:
			goto _5
		}
		goto _1
	_5:
		switch p.c().tok {
		case INTERFACE:
			if p.interfaceType() == nil {
				goto _6
			}
		default:
			goto _6
		}
		goto _1
	_6:
		switch p.c().tok {
		case LBRACK:
			if p.sliceType() == nil {
				goto _7
			}
		default:
			goto _7
		}
		goto _1
	_7:
		switch p.c().tok {
		case MAP:
			if p.mapType() == nil {
				goto _8
			}
		default:
			goto _8
		}
		goto _1
	_8:
		switch p.c().tok {
		case ARROW, CHAN:
			if p.channelType() == nil {
				goto _9
			}
		default:
			goto _9
		}
		goto _1
	_9:
		goto _0
	}
_1:
	return &TypeLitNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeNameNode represents

//	TypeName = QualifiedIdent | identifier .
type TypeNameNode = struct{}

func (p *parser) typeName() *TypeNameNode {
	ix := p.ix
	// false: IDENT
	// false: IDENT
	// single:
	// multi: IDENT
	// ebnf.Alternative: QualifiedIdent | identifier
	{
		switch p.c().tok {
		case IDENT:
			if p.qualifiedIdent() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		if p.c().tok == IDENT {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &TypeNameNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeParamDeclNode represents

//	TypeParamDecl = IdentifierList TypeConstraint .
type TypeParamDeclNode = struct{}

func (p *parser) typeParamDecl() *TypeParamDeclNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList TypeConstraint
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE:
			if p.typeConstraint() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &TypeParamDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeParamListNode represents

//	TypeParamList = TypeParamDecl { "," TypeParamDecl } .
type TypeParamListNode = struct{}

func (p *parser) typeParamList() *TypeParamListNode {
	ix := p.ix
	// ebnf.Sequence: TypeParamDecl { "," TypeParamDecl }
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.typeParamDecl() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	_1:
		// *ebnf.Repetition: { "," TypeParamDecl }
		switch p.c().tok {
		case COMMA:
			// ebnf.Sequence: "," TypeParamDecl
			ix := p.ix
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case IDENT:
				if p.typeParamDecl() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
			goto _1
		}
	_2:
	}
	return &TypeParamListNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeParametersNode represents

//	TypeParameters = "[" TypeParamList [ "," ] "]" .
type TypeParametersNode = struct{}

func (p *parser) typeParameters() *TypeParametersNode {
	ix := p.ix
	// ebnf.Sequence: "[" TypeParamList [ "," ] "]"
	{
		ix := p.ix
		if p.c().tok == LBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case IDENT:
			if p.typeParamList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ "," ]
		switch p.c().tok {
		case COMMA:
			if p.c().tok == COMMA {
				p.ix++
				p.budget--
			} else {
				goto _1
			}
		}
	_1:
		if p.c().tok == RBRACK {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeParametersNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeSpecNode represents

//	TypeSpec = AliasDecl | TypeDef .
type TypeSpecNode = struct{}

func (p *parser) typeSpec() *TypeSpecNode {
	ix := p.ix
	// false: IDENT
	// false: IDENT
	// single:
	// multi: IDENT
	// ebnf.Alternative: AliasDecl | TypeDef
	{
		switch p.c().tok {
		case IDENT:
			if p.aliasDecl() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case IDENT:
			if p.typeDef() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &TypeSpecNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeSwitchCaseNode represents

//	TypeSwitchCase = "case" TypeList | "default" .
type TypeSwitchCaseNode = struct{}

func (p *parser) typeSwitchCase() *TypeSwitchCaseNode {
	ix := p.ix
	// true: CASE
	// true: DEFAULT
	// single: CASE, DEFAULT
	// multi:
	// ebnf.Alternative: "case" TypeList | "default"
	{
		// ebnf.Sequence: "case" TypeList
		{
			ix := p.ix
			if p.c().tok == CASE {
				p.ix++
				p.budget--
			} else {
				p.back(ix)
				goto _2
			}
			switch p.c().tok {
			case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
				if p.typeList() == nil {
					p.back(ix)
					goto _2
				}
			default:
				p.back(ix)
				goto _2
			}
		}
		goto _1
	_2:
		if p.c().tok == DEFAULT {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &TypeSwitchCaseNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeSwitchGuardNode represents

//	TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
type TypeSwitchGuardNode = struct{}

func (p *parser) typeSwitchGuard() *TypeSwitchGuardNode {
	ix := p.ix
	// ebnf.Sequence: [ identifier ":=" ] PrimaryExpr "." "(" "type" ")"
	{
		ix := p.ix
		// *ebnf.Option: [ identifier ":=" ]
		switch p.c().tok {
		case IDENT:
			// ebnf.Sequence: identifier ":="
			{
				ix := p.ix
				if p.c().tok == IDENT {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
				if p.c().tok == DEFINE {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
			}
		}
	_1:
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.primaryExpr() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == PERIOD {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == LPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == TYPE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		if p.c().tok == RPAREN {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeSwitchGuardNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeSwitchStmtNode represents

//	TypeSwitchStmt = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
type TypeSwitchStmtNode = struct{}

func (p *parser) typeSwitchStmt() *TypeSwitchStmtNode {
	ix := p.ix
	// ebnf.Sequence: "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}"
	{
		ix := p.ix
		if p.c().tok == SWITCH {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Option: [ SimpleStmt ";" ]
		switch p.c().tok {
		case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, SEMICOLON, STRING, STRUCT, SUB, XOR:
			// ebnf.Sequence: SimpleStmt ";"
			{
				ix := p.ix
				switch p.c().tok {
				case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR /* ε */ :
					if p.simpleStmt() == nil {
						p.back(ix)
						goto _1
					}
				}
				if p.c().tok == SEMICOLON {
					p.ix++
					p.budget--
				} else {
					p.back(ix)
					goto _1
				}
			}
		}
	_1:
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.typeSwitchGuard() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		if p.c().tok == LBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	_2:
		// *ebnf.Repetition: { TypeCaseClause }
		switch p.c().tok {
		case CASE, DEFAULT:
			switch p.c().tok {
			case CASE, DEFAULT:
				if p.typeCaseClause() == nil {
					goto _3
				}
			default:
				goto _3
			}
			goto _2
		}
	_3:
		if p.c().tok == RBRACE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
	}
	return &TypeSwitchStmtNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// TypeTermNode represents

//	TypeTerm = Type | UnderlyingType .
type TypeTermNode = struct{}

func (p *parser) typeTerm() *TypeTermNode {
	ix := p.ix
	// true: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
	// true: TILDE
	// single: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT, TILDE
	// multi:
	// ebnf.Alternative: Type | UnderlyingType
	{
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		switch p.c().tok {
		case TILDE:
			if p.underlyingType() == nil {
				goto _3
			}
		default:
			goto _3
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &TypeTermNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// UnaryExprNode represents

//	UnaryExpr = PrimaryExpr | UnaryOp UnaryExpr .
type UnaryExprNode = struct{}

func (p *parser) unaryExpr() *UnaryExprNode {
	ix := p.ix
	// false: ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT
	// false: ADD, AND, ARROW, MUL, NOT, SUB, XOR
	// single: ADD, AND, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, NOT, STRING, STRUCT, SUB, XOR
	// multi: ARROW, MUL
	// ebnf.Alternative: PrimaryExpr | UnaryOp UnaryExpr
	{
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.primaryExpr() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		// ebnf.Sequence: UnaryOp UnaryExpr
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, MUL, NOT, SUB, XOR:
				if p.unaryOp() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExpr() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &UnaryExprNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// UnaryExprPreBlockPreBlockNode represents

//	UnaryExprPreBlockPreBlock = PrimaryExprPreBlock | UnaryOp UnaryExprPreBlockPreBlock .
type UnaryExprPreBlockPreBlockNode = struct{}

func (p *parser) unaryExprPreBlockPreBlock() *UnaryExprPreBlockPreBlockNode {
	ix := p.ix
	// false: ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT
	// false: ADD, AND, ARROW, MUL, NOT, SUB, XOR
	// single: ADD, AND, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, NOT, STRING, STRUCT, SUB, XOR
	// multi: ARROW, MUL
	// ebnf.Alternative: PrimaryExprPreBlock | UnaryOp UnaryExprPreBlockPreBlock
	{
		switch p.c().tok {
		case ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRING, STRUCT:
			if p.primaryExprPreBlock() == nil {
				goto _2
			}
		default:
			goto _2
		}
		goto _1
	_2:
		// ebnf.Sequence: UnaryOp UnaryExprPreBlockPreBlock
		{
			ix := p.ix
			switch p.c().tok {
			case ADD, AND, ARROW, MUL, NOT, SUB, XOR:
				if p.unaryOp() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
			switch p.c().tok {
			case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
				if p.unaryExprPreBlockPreBlock() == nil {
					p.back(ix)
					goto _3
				}
			default:
				p.back(ix)
				goto _3
			}
		}
		goto _1
	_3:
		goto _0
	}
_1:
	return &UnaryExprPreBlockPreBlockNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// UnaryOpNode represents

//	UnaryOp = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
type UnaryOpNode = struct{}

func (p *parser) unaryOp() *UnaryOpNode {
	ix := p.ix
	// true: ADD
	// true: SUB
	// true: NOT
	// true: XOR
	// true: MUL
	// true: AND
	// true: ARROW
	// single: ADD, AND, ARROW, MUL, NOT, SUB, XOR
	// multi:
	// ebnf.Alternative: "+" | "-" | "!" | "^" | "*" | "&" | "<-"
	{
		if p.c().tok == ADD {
			p.ix++
			p.budget--
		} else {
			goto _2
		}
		goto _1
	_2:
		if p.c().tok == SUB {
			p.ix++
			p.budget--
		} else {
			goto _3
		}
		goto _1
	_3:
		if p.c().tok == NOT {
			p.ix++
			p.budget--
		} else {
			goto _4
		}
		goto _1
	_4:
		if p.c().tok == XOR {
			p.ix++
			p.budget--
		} else {
			goto _5
		}
		goto _1
	_5:
		if p.c().tok == MUL {
			p.ix++
			p.budget--
		} else {
			goto _6
		}
		goto _1
	_6:
		if p.c().tok == AND {
			p.ix++
			p.budget--
		} else {
			goto _7
		}
		goto _1
	_7:
		if p.c().tok == ARROW {
			p.ix++
			p.budget--
		} else {
			goto _8
		}
		goto _1
	_8:
		goto _0
	}
_1:
	return &UnaryOpNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// UnderlyingTypeNode represents

//	UnderlyingType = "~" Type .
type UnderlyingTypeNode = struct{}

func (p *parser) underlyingType() *UnderlyingTypeNode {
	ix := p.ix
	// ebnf.Sequence: "~" Type
	{
		ix := p.ix
		if p.c().tok == TILDE {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		switch p.c().tok {
		case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			if p.type1() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
	}
	return &UnderlyingTypeNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// VarDeclNode represents

//	VarDecl = "var" ( VarSpec | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")" ) .
type VarDeclNode = struct{}

func (p *parser) varDecl() *VarDeclNode {
	ix := p.ix
	// ebnf.Sequence: "var" ( VarSpec | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")" )
	{
		ix := p.ix
		if p.c().tok == VAR {
			p.ix++
			p.budget--
		} else {
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( VarSpec | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")" )
		switch p.c().tok {
		case IDENT, LPAREN:
			// true: IDENT
			// true: LPAREN
			// single: IDENT, LPAREN
			// multi:
			// ebnf.Alternative: VarSpec | "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")"
			{
				switch p.c().tok {
				case IDENT:
					if p.varSpec() == nil {
						goto _2
					}
				default:
					goto _2
				}
				goto _1
			_2:
				// ebnf.Sequence: "(" [ VarSpec { ";" VarSpec } [ ";" ] ] ")"
				{
					ix := p.ix
					if p.c().tok == LPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
					// *ebnf.Option: [ VarSpec { ";" VarSpec } [ ";" ] ]
					switch p.c().tok {
					case IDENT:
						// ebnf.Sequence: VarSpec { ";" VarSpec } [ ";" ]
						{
							ix := p.ix
							switch p.c().tok {
							case IDENT:
								if p.varSpec() == nil {
									p.back(ix)
									goto _4
								}
							default:
								p.back(ix)
								goto _4
							}
						_5:
							// *ebnf.Repetition: { ";" VarSpec }
							switch p.c().tok {
							case SEMICOLON:
								// ebnf.Sequence: ";" VarSpec
								ix := p.ix
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									p.back(ix)
									goto _6
								}
								switch p.c().tok {
								case IDENT:
									if p.varSpec() == nil {
										p.back(ix)
										goto _6
									}
								default:
									p.back(ix)
									goto _6
								}
								goto _5
							}
						_6:
							// *ebnf.Option: [ ";" ]
							switch p.c().tok {
							case SEMICOLON:
								if p.c().tok == SEMICOLON {
									p.ix++
									p.budget--
								} else {
									goto _7
								}
							}
						_7:
						}
					}
				_4:
					if p.c().tok == RPAREN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _3
					}
				}
				goto _1
			_3:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
	}
	return &VarDeclNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}

// VarSpecNode represents

//	VarSpec = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
type VarSpecNode = struct{}

func (p *parser) varSpec() *VarSpecNode {
	ix := p.ix
	// ebnf.Sequence: IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList )
	{
		ix := p.ix
		switch p.c().tok {
		case IDENT:
			if p.identifierList() == nil {
				p.back(ix)
				goto _0
			}
		default:
			p.back(ix)
			goto _0
		}
		// *ebnf.Group: ( Type [ "=" ExpressionList ] | "=" ExpressionList )
		switch p.c().tok {
		case ARROW, ASSIGN, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
			// true: ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
			// true: ASSIGN
			// single: ARROW, ASSIGN, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT
			// multi:
			// ebnf.Alternative: Type [ "=" ExpressionList ] | "=" ExpressionList
			{
				// ebnf.Sequence: Type [ "=" ExpressionList ]
				{
					ix := p.ix
					switch p.c().tok {
					case ARROW, CHAN, FUNC, IDENT, INTERFACE, LBRACK, LPAREN, MAP, MUL, STRUCT:
						if p.type1() == nil {
							p.back(ix)
							goto _2
						}
					default:
						p.back(ix)
						goto _2
					}
					// *ebnf.Option: [ "=" ExpressionList ]
					switch p.c().tok {
					case ASSIGN:
						// ebnf.Sequence: "=" ExpressionList
						{
							ix := p.ix
							if p.c().tok == ASSIGN {
								p.ix++
								p.budget--
							} else {
								p.back(ix)
								goto _3
							}
							switch p.c().tok {
							case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
								if p.expressionList() == nil {
									p.back(ix)
									goto _3
								}
							default:
								p.back(ix)
								goto _3
							}
						}
					}
				_3:
				}
				goto _1
			_2:
				// ebnf.Sequence: "=" ExpressionList
				{
					ix := p.ix
					if p.c().tok == ASSIGN {
						p.ix++
						p.budget--
					} else {
						p.back(ix)
						goto _4
					}
					switch p.c().tok {
					case ADD, AND, ARROW, CHAN, CHAR, FLOAT, FUNC, IDENT, IMAG, INT, INTERFACE, LBRACK, LPAREN, MAP, MUL, NOT, STRING, STRUCT, SUB, XOR:
						if p.expressionList() == nil {
							p.back(ix)
							goto _4
						}
					default:
						p.back(ix)
						goto _4
					}
				}
				goto _1
			_4:
				p.back(ix)
				goto _0
			}
		_1:
			;
		default:
			p.back(ix)
			goto _0
		}
	}
	return &VarSpecNode{}
	goto _0
_0:
	p.back(ix)
	return nil
}
