float_lit = "FLOAT" .
identifier = "IDENT" .
imaginary_lit = "IMAG" .
int_lit = "INT" .
rune_lit = "CHAR" .
string_lit = "STRING" .

AliasDecl = identifier "=" Type .
Arguments      = "(" [ ( ExpressionList | Type [ "," ExpressionList ] ) [ "..." ] [ "," ] ] ")" .
ArrayLength = Expression .
ArrayType   = "[" ArrayLength "]" ElementType .
Assignment = ExpressionList assign_op ExpressionList .
BaseType    = Type .
BasicLit    = int_lit | float_lit | imaginary_lit | rune_lit | string_lit .
Block = "{" StatementList "}" .
BreakStmt = "break" [ Label ] .
Channel  = Expression .
ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType .
CommCase   = "case" ( SendStmt | RecvStmt ) | "default" .
CommClause = CommCase ":" StatementList .
CompositeLit  = LiteralType LiteralValue .
Condition = Expression .
ConstDecl      = "const" ( ConstSpec | "(" { ConstSpec ";" } ")" ) .
ConstSpec      = IdentifierList [ [ Type ] "=" ExpressionList ] .
ContinueStmt = "continue" [ Label ] .
Conversion = Type "(" Expression [ "," ] ")" .
Declaration   = ConstDecl | TypeDecl | VarDecl .
DeferStmt = "defer" Expression .
Element       = Expression | LiteralValue .
ElementList   = KeyedElement { "," KeyedElement } .
ElementType = Type .
EmbeddedField = [ "*" ] TypeName .
EmptyStmt = .
ExprCaseClause = ExprSwitchCase ":" StatementList .
ExprSwitchCase = "case" ExpressionList | "default" .
ExprSwitchStmt = "switch" [ SimpleStmt ";" ] [ Expression ] "{" { ExprCaseClause } "}" .
Expression = UnaryExpr | Expression binary_op Expression .
ExpressionList = Expression { "," Expression } .
ExpressionStmt = Expression .
FallthroughStmt = "fallthrough" .
FieldDecl     = (IdentifierList Type | EmbeddedField) [ Tag ] .
FieldName     = identifier .
ForClause = [ InitStmt ] ";" [ Condition ] ";" [ PostStmt ] .
ForStmt = "for" [ Condition | ForClause | RangeClause ] Block .
FunctionBody = Block .
FunctionDecl = "func" FunctionName [ TypeParameters ] Signature [ FunctionBody ] .
FunctionLit = "func" Signature FunctionBody .
FunctionName = identifier .
FunctionType   = "func" Signature .
GoStmt = "go" Expression .
GotoStmt = "goto" Label .
IdentifierList = identifier { "," identifier } .
IfStmt = "if" [ SimpleStmt ";" ] Expression Block [ "else" ( IfStmt | Block ) ] .
ImportDecl       = "import" ( ImportSpec | "(" { ImportSpec ";" } ")" ) .
ImportPath       = string_lit .
ImportSpec       = [ "." | PackageName ] ImportPath .
IncDecStmt = Expression ( "++" | "--" ) .
Index          = "[" Expression "]" .
InitStmt = SimpleStmt .
InterfaceElem  = MethodElem | TypeElem .
InterfaceType  = "interface" "{" { InterfaceElem ";" } "}" .
Key           = FieldName | Expression | LiteralValue .
KeyType     = Type .
KeyedElement  = [ Key ":" ] Element .
Label       = identifier .
LabeledStmt = Label ":" Statement .
Literal     = BasicLit | CompositeLit | FunctionLit .
LiteralType   = StructType | ArrayType | "[" "..." "]" ElementType | SliceType | MapType | TypeName .
LiteralValue  = "{" [ ElementList [ "," ] ] "}" .
MapType     = "map" "[" KeyType "]" ElementType .
MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
MethodElem     = MethodName Signature .
MethodExpr    = ReceiverType "." MethodName .
MethodName     = identifier .
Operand     = Literal | OperandName [ TypeArgs ] | "(" Expression ")" .
OperandName = identifier | QualifiedIdent .
PackageClause  = "package" PackageName .
PackageName    = identifier .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
ParameterList  = ParameterDecl { "," ParameterDecl } .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
PointerType = "*" BaseType .
PostStmt = SimpleStmt .
PrimaryExpr = Operand | Conversion | MethodExpr | PrimaryExpr Selector | PrimaryExpr Index | PrimaryExpr Slice | PrimaryExpr TypeAssertion | PrimaryExpr Arguments .
QualifiedIdent = PackageName "." identifier .
RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .
Receiver   = Parameters .
ReceiverType  = Type .
RecvExpr   = Expression .
RecvStmt   = [ ExpressionList "=" | IdentifierList ":=" ] RecvExpr .
Result         = Parameters | Type .
ReturnStmt = "return" [ ExpressionList ] .
SelectStmt = "select" "{" { CommClause } "}" .
Selector       = "." identifier .
SendStmt = Channel "<-" Expression .
ShortVarDecl = IdentifierList ":=" ExpressionList .
Signature      = Parameters [ Result ] .
SimpleStmt = EmptyStmt | ExpressionStmt | SendStmt | IncDecStmt | Assignment | ShortVarDecl .
Slice          = "[" [ Expression ] ":" [ Expression ] "]" | "[" [ Expression ] ":" Expression ":" Expression "]" .
SliceType = "[" "]" ElementType .
SourceFile       = PackageClause ";" { ImportDecl ";" } { TopLevelDecl ";" } .
Statement = Declaration | LabeledStmt | SimpleStmt | GoStmt | ReturnStmt | BreakStmt | ContinueStmt | GotoStmt | FallthroughStmt | Block | IfStmt | SwitchStmt | SelectStmt | ForStmt | DeferStmt .
StatementList = { Statement ";" } .
StructType    = "struct" "{" { FieldDecl ";" } "}" .
SwitchStmt = ExprSwitchStmt | TypeSwitchStmt .
Tag           = string_lit .
TopLevelDecl  = Declaration | FunctionDecl | MethodDecl .
Type      = TypeName [ TypeArgs ] | TypeLit | "(" Type ")" .
TypeArgs  = "[" TypeList [ "," ] "]" .
TypeAssertion  = "." "(" Type ")" .
TypeCaseClause  = TypeSwitchCase ":" StatementList .
TypeConstraint = TypeElem .
TypeDecl = "type" ( TypeSpec | "(" { TypeSpec ";" } ")" ) .
TypeDef = identifier [ TypeParameters ] Type .
TypeElem       = TypeTerm { "|" TypeTerm } .
TypeList  = Type { "," Type } .
TypeLit   = ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | ChannelType .
TypeName  = identifier | QualifiedIdent .
TypeParamDecl   = IdentifierList TypeConstraint .
TypeParamList   = TypeParamDecl { "," TypeParamDecl } .
TypeParameters  = "[" TypeParamList [ "," ] "]" .
TypeSpec = AliasDecl | TypeDef .
TypeSwitchCase  = "case" TypeList | "default" .
TypeSwitchGuard = [ identifier ":=" ] PrimaryExpr "." "(" "type" ")" .
TypeSwitchStmt  = "switch" [ SimpleStmt ";" ] TypeSwitchGuard "{" { TypeCaseClause } "}" .
TypeTerm       = Type | UnderlyingType .
UnaryExpr  = PrimaryExpr | unary_op UnaryExpr .
UnderlyingType = "~" Type .
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
add_op     = "+" | "-" | "|" | "^" .
assign_op = [ add_op | mul_op ] "=" .
binary_op  = "||" | "&&" | rel_op | add_op | mul_op .
mul_op     = "*" | "/" | "%" | "<<" | ">>" | "&" | "&^" .
rel_op     = "==" | "!=" | "<" | "<=" | ">" | ">=" .
unary_op   = "+" | "-" | "!" | "^" | "*" | "&" | "<-" .
